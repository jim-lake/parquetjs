//
// Autogenerated by Thrift Compiler (0.22.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
"use strict";

var thrift = require('thrift');
var Thrift = thrift.Thrift;
var Q = thrift.Q;
var Int64 = require('node-int64');


var ttypes = module.exports = {};
ttypes.Type = {
  'BOOLEAN' : 0,
  'INT32' : 1,
  'INT64' : 2,
  'INT96' : 3,
  'FLOAT' : 4,
  'DOUBLE' : 5,
  'BYTE_ARRAY' : 6,
  'FIXED_LEN_BYTE_ARRAY' : 7
};
ttypes.ConvertedType = {
  'UTF8' : 0,
  'MAP' : 1,
  'MAP_KEY_VALUE' : 2,
  'LIST' : 3,
  'ENUM' : 4,
  'DECIMAL' : 5,
  'DATE' : 6,
  'TIME_MILLIS' : 7,
  'TIME_MICROS' : 8,
  'TIMESTAMP_MILLIS' : 9,
  'TIMESTAMP_MICROS' : 10,
  'UINT_8' : 11,
  'UINT_16' : 12,
  'UINT_32' : 13,
  'UINT_64' : 14,
  'INT_8' : 15,
  'INT_16' : 16,
  'INT_32' : 17,
  'INT_64' : 18,
  'JSON' : 19,
  'BSON' : 20,
  'INTERVAL' : 21
};
ttypes.FieldRepetitionType = {
  'REQUIRED' : 0,
  'OPTIONAL' : 1,
  'REPEATED' : 2
};
ttypes.EdgeInterpolationAlgorithm = {
  'SPHERICAL' : 0,
  'VINCENTY' : 1,
  'THOMAS' : 2,
  'ANDOYER' : 3,
  'KARNEY' : 4
};
ttypes.Encoding = {
  'PLAIN' : 0,
  'PLAIN_DICTIONARY' : 2,
  'RLE' : 3,
  'BIT_PACKED' : 4,
  'DELTA_BINARY_PACKED' : 5,
  'DELTA_LENGTH_BYTE_ARRAY' : 6,
  'DELTA_BYTE_ARRAY' : 7,
  'RLE_DICTIONARY' : 8,
  'BYTE_STREAM_SPLIT' : 9
};
ttypes.CompressionCodec = {
  'UNCOMPRESSED' : 0,
  'SNAPPY' : 1,
  'GZIP' : 2,
  'LZO' : 3,
  'BROTLI' : 4,
  'LZ4' : 5,
  'ZSTD' : 6,
  'LZ4_RAW' : 7
};
ttypes.PageType = {
  'DATA_PAGE' : 0,
  'INDEX_PAGE' : 1,
  'DICTIONARY_PAGE' : 2,
  'DATA_PAGE_V2' : 3
};
ttypes.BoundaryOrder = {
  'UNORDERED' : 0,
  'ASCENDING' : 1,
  'DESCENDING' : 2
};
var SizeStatistics = module.exports.SizeStatistics = function(args) {
  this.unencoded_byte_array_data_bytes = null;
  this.repetition_level_histogram = null;
  this.definition_level_histogram = null;
  if (args) {
    if (args.unencoded_byte_array_data_bytes !== undefined && args.unencoded_byte_array_data_bytes !== null) {
      this.unencoded_byte_array_data_bytes = args.unencoded_byte_array_data_bytes;
    }
    if (args.repetition_level_histogram !== undefined && args.repetition_level_histogram !== null) {
      this.repetition_level_histogram = Thrift.copyList(args.repetition_level_histogram, [null]);
    }
    if (args.definition_level_histogram !== undefined && args.definition_level_histogram !== null) {
      this.definition_level_histogram = Thrift.copyList(args.definition_level_histogram, [null]);
    }
  }
};
SizeStatistics.prototype = {};
SizeStatistics.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.unencoded_byte_array_data_bytes = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.repetition_level_histogram = [];
        var _rtmp31 = input.readListBegin();
        var _size0 = _rtmp31.size || 0;
        for (var _i2 = 0; _i2 < _size0; ++_i2) {
          var elem3 = null;
          elem3 = input.readI64();
          this.repetition_level_histogram.push(elem3);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        this.definition_level_histogram = [];
        var _rtmp35 = input.readListBegin();
        var _size4 = _rtmp35.size || 0;
        for (var _i6 = 0; _i6 < _size4; ++_i6) {
          var elem7 = null;
          elem7 = input.readI64();
          this.definition_level_histogram.push(elem7);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SizeStatistics.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('SizeStatistics');
  if (this.unencoded_byte_array_data_bytes !== null && this.unencoded_byte_array_data_bytes !== undefined) {
    output.writeFieldBegin('unencoded_byte_array_data_bytes', Thrift.Type.I64, 1);
    output.writeI64(this.unencoded_byte_array_data_bytes);
    output.writeFieldEnd();
  }
  if (this.repetition_level_histogram !== null && this.repetition_level_histogram !== undefined) {
    output.writeFieldBegin('repetition_level_histogram', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.I64, this.repetition_level_histogram.length);
    for (var iter8 in this.repetition_level_histogram) {
      if (this.repetition_level_histogram.hasOwnProperty(iter8)) {
        iter8 = this.repetition_level_histogram[iter8];
        output.writeI64(iter8);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.definition_level_histogram !== null && this.definition_level_histogram !== undefined) {
    output.writeFieldBegin('definition_level_histogram', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.I64, this.definition_level_histogram.length);
    for (var iter9 in this.definition_level_histogram) {
      if (this.definition_level_histogram.hasOwnProperty(iter9)) {
        iter9 = this.definition_level_histogram[iter9];
        output.writeI64(iter9);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var BoundingBox = module.exports.BoundingBox = function(args) {
  this.xmin = null;
  this.xmax = null;
  this.ymin = null;
  this.ymax = null;
  this.zmin = null;
  this.zmax = null;
  this.mmin = null;
  this.mmax = null;
  if (args) {
    if (args.xmin !== undefined && args.xmin !== null) {
      this.xmin = args.xmin;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field xmin is unset!');
    }
    if (args.xmax !== undefined && args.xmax !== null) {
      this.xmax = args.xmax;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field xmax is unset!');
    }
    if (args.ymin !== undefined && args.ymin !== null) {
      this.ymin = args.ymin;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ymin is unset!');
    }
    if (args.ymax !== undefined && args.ymax !== null) {
      this.ymax = args.ymax;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ymax is unset!');
    }
    if (args.zmin !== undefined && args.zmin !== null) {
      this.zmin = args.zmin;
    }
    if (args.zmax !== undefined && args.zmax !== null) {
      this.zmax = args.zmax;
    }
    if (args.mmin !== undefined && args.mmin !== null) {
      this.mmin = args.mmin;
    }
    if (args.mmax !== undefined && args.mmax !== null) {
      this.mmax = args.mmax;
    }
  }
};
BoundingBox.prototype = {};
BoundingBox.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.DOUBLE) {
        this.xmin = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.DOUBLE) {
        this.xmax = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ymin = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ymax = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.DOUBLE) {
        this.zmin = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.DOUBLE) {
        this.zmax = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.DOUBLE) {
        this.mmin = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.DOUBLE) {
        this.mmax = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BoundingBox.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('BoundingBox');
  if (this.xmin !== null && this.xmin !== undefined) {
    output.writeFieldBegin('xmin', Thrift.Type.DOUBLE, 1);
    output.writeDouble(this.xmin);
    output.writeFieldEnd();
  }
  if (this.xmax !== null && this.xmax !== undefined) {
    output.writeFieldBegin('xmax', Thrift.Type.DOUBLE, 2);
    output.writeDouble(this.xmax);
    output.writeFieldEnd();
  }
  if (this.ymin !== null && this.ymin !== undefined) {
    output.writeFieldBegin('ymin', Thrift.Type.DOUBLE, 3);
    output.writeDouble(this.ymin);
    output.writeFieldEnd();
  }
  if (this.ymax !== null && this.ymax !== undefined) {
    output.writeFieldBegin('ymax', Thrift.Type.DOUBLE, 4);
    output.writeDouble(this.ymax);
    output.writeFieldEnd();
  }
  if (this.zmin !== null && this.zmin !== undefined) {
    output.writeFieldBegin('zmin', Thrift.Type.DOUBLE, 5);
    output.writeDouble(this.zmin);
    output.writeFieldEnd();
  }
  if (this.zmax !== null && this.zmax !== undefined) {
    output.writeFieldBegin('zmax', Thrift.Type.DOUBLE, 6);
    output.writeDouble(this.zmax);
    output.writeFieldEnd();
  }
  if (this.mmin !== null && this.mmin !== undefined) {
    output.writeFieldBegin('mmin', Thrift.Type.DOUBLE, 7);
    output.writeDouble(this.mmin);
    output.writeFieldEnd();
  }
  if (this.mmax !== null && this.mmax !== undefined) {
    output.writeFieldBegin('mmax', Thrift.Type.DOUBLE, 8);
    output.writeDouble(this.mmax);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var GeospatialStatistics = module.exports.GeospatialStatistics = function(args) {
  this.bbox = null;
  this.geospatial_types = null;
  if (args) {
    if (args.bbox !== undefined && args.bbox !== null) {
      this.bbox = new ttypes.BoundingBox(args.bbox);
    }
    if (args.geospatial_types !== undefined && args.geospatial_types !== null) {
      this.geospatial_types = Thrift.copyList(args.geospatial_types, [null]);
    }
  }
};
GeospatialStatistics.prototype = {};
GeospatialStatistics.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.bbox = new ttypes.BoundingBox();
        this.bbox[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.geospatial_types = [];
        var _rtmp311 = input.readListBegin();
        var _size10 = _rtmp311.size || 0;
        for (var _i12 = 0; _i12 < _size10; ++_i12) {
          var elem13 = null;
          elem13 = input.readI32();
          this.geospatial_types.push(elem13);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GeospatialStatistics.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('GeospatialStatistics');
  if (this.bbox !== null && this.bbox !== undefined) {
    output.writeFieldBegin('bbox', Thrift.Type.STRUCT, 1);
    this.bbox[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.geospatial_types !== null && this.geospatial_types !== undefined) {
    output.writeFieldBegin('geospatial_types', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.I32, this.geospatial_types.length);
    for (var iter14 in this.geospatial_types) {
      if (this.geospatial_types.hasOwnProperty(iter14)) {
        iter14 = this.geospatial_types[iter14];
        output.writeI32(iter14);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Statistics = module.exports.Statistics = function(args) {
  this.max = null;
  this.min = null;
  this.null_count = null;
  this.distinct_count = null;
  this.max_value = null;
  this.min_value = null;
  this.is_max_value_exact = null;
  this.is_min_value_exact = null;
  if (args) {
    if (args.max !== undefined && args.max !== null) {
      this.max = args.max;
    }
    if (args.min !== undefined && args.min !== null) {
      this.min = args.min;
    }
    if (args.null_count !== undefined && args.null_count !== null) {
      this.null_count = args.null_count;
    }
    if (args.distinct_count !== undefined && args.distinct_count !== null) {
      this.distinct_count = args.distinct_count;
    }
    if (args.max_value !== undefined && args.max_value !== null) {
      this.max_value = args.max_value;
    }
    if (args.min_value !== undefined && args.min_value !== null) {
      this.min_value = args.min_value;
    }
    if (args.is_max_value_exact !== undefined && args.is_max_value_exact !== null) {
      this.is_max_value_exact = args.is_max_value_exact;
    }
    if (args.is_min_value_exact !== undefined && args.is_min_value_exact !== null) {
      this.is_min_value_exact = args.is_min_value_exact;
    }
  }
};
Statistics.prototype = {};
Statistics.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.max = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.min = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.null_count = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I64) {
        this.distinct_count = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.max_value = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.min_value = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.BOOL) {
        this.is_max_value_exact = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.BOOL) {
        this.is_min_value_exact = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Statistics.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('Statistics');
  if (this.max !== null && this.max !== undefined) {
    output.writeFieldBegin('max', Thrift.Type.STRING, 1);
    output.writeBinary(this.max);
    output.writeFieldEnd();
  }
  if (this.min !== null && this.min !== undefined) {
    output.writeFieldBegin('min', Thrift.Type.STRING, 2);
    output.writeBinary(this.min);
    output.writeFieldEnd();
  }
  if (this.null_count !== null && this.null_count !== undefined) {
    output.writeFieldBegin('null_count', Thrift.Type.I64, 3);
    output.writeI64(this.null_count);
    output.writeFieldEnd();
  }
  if (this.distinct_count !== null && this.distinct_count !== undefined) {
    output.writeFieldBegin('distinct_count', Thrift.Type.I64, 4);
    output.writeI64(this.distinct_count);
    output.writeFieldEnd();
  }
  if (this.max_value !== null && this.max_value !== undefined) {
    output.writeFieldBegin('max_value', Thrift.Type.STRING, 5);
    output.writeBinary(this.max_value);
    output.writeFieldEnd();
  }
  if (this.min_value !== null && this.min_value !== undefined) {
    output.writeFieldBegin('min_value', Thrift.Type.STRING, 6);
    output.writeBinary(this.min_value);
    output.writeFieldEnd();
  }
  if (this.is_max_value_exact !== null && this.is_max_value_exact !== undefined) {
    output.writeFieldBegin('is_max_value_exact', Thrift.Type.BOOL, 7);
    output.writeBool(this.is_max_value_exact);
    output.writeFieldEnd();
  }
  if (this.is_min_value_exact !== null && this.is_min_value_exact !== undefined) {
    output.writeFieldBegin('is_min_value_exact', Thrift.Type.BOOL, 8);
    output.writeBool(this.is_min_value_exact);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var StringType = module.exports.StringType = function(args) {
};
StringType.prototype = {};
StringType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

StringType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('StringType');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var UUIDType = module.exports.UUIDType = function(args) {
};
UUIDType.prototype = {};
UUIDType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UUIDType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('UUIDType');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var MapType = module.exports.MapType = function(args) {
};
MapType.prototype = {};
MapType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

MapType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('MapType');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ListType = module.exports.ListType = function(args) {
};
ListType.prototype = {};
ListType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ListType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('ListType');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var EnumType = module.exports.EnumType = function(args) {
};
EnumType.prototype = {};
EnumType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

EnumType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('EnumType');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var DateType = module.exports.DateType = function(args) {
};
DateType.prototype = {};
DateType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

DateType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('DateType');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Float16Type = module.exports.Float16Type = function(args) {
};
Float16Type.prototype = {};
Float16Type.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Float16Type.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('Float16Type');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var NullType = module.exports.NullType = function(args) {
};
NullType.prototype = {};
NullType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NullType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('NullType');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var DecimalType = module.exports.DecimalType = function(args) {
  this.scale = null;
  this.precision = null;
  if (args) {
    if (args.scale !== undefined && args.scale !== null) {
      this.scale = args.scale;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field scale is unset!');
    }
    if (args.precision !== undefined && args.precision !== null) {
      this.precision = args.precision;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field precision is unset!');
    }
  }
};
DecimalType.prototype = {};
DecimalType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.scale = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.precision = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

DecimalType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('DecimalType');
  if (this.scale !== null && this.scale !== undefined) {
    output.writeFieldBegin('scale', Thrift.Type.I32, 1);
    output.writeI32(this.scale);
    output.writeFieldEnd();
  }
  if (this.precision !== null && this.precision !== undefined) {
    output.writeFieldBegin('precision', Thrift.Type.I32, 2);
    output.writeI32(this.precision);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var MilliSeconds = module.exports.MilliSeconds = function(args) {
};
MilliSeconds.prototype = {};
MilliSeconds.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

MilliSeconds.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('MilliSeconds');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var MicroSeconds = module.exports.MicroSeconds = function(args) {
};
MicroSeconds.prototype = {};
MicroSeconds.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

MicroSeconds.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('MicroSeconds');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var NanoSeconds = module.exports.NanoSeconds = function(args) {
};
NanoSeconds.prototype = {};
NanoSeconds.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NanoSeconds.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('NanoSeconds');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TimeUnit = module.exports.TimeUnit = function(args) {
  this.MILLIS = null;
  this.MICROS = null;
  this.NANOS = null;
  if (args) {
    if (args.MILLIS !== undefined && args.MILLIS !== null) {
      this.MILLIS = new ttypes.MilliSeconds(args.MILLIS);
    }
    if (args.MICROS !== undefined && args.MICROS !== null) {
      this.MICROS = new ttypes.MicroSeconds(args.MICROS);
    }
    if (args.NANOS !== undefined && args.NANOS !== null) {
      this.NANOS = new ttypes.NanoSeconds(args.NANOS);
    }
  }
};
TimeUnit.prototype = {};
TimeUnit.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.MILLIS = new ttypes.MilliSeconds();
        this.MILLIS[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.MICROS = new ttypes.MicroSeconds();
        this.MICROS[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.NANOS = new ttypes.NanoSeconds();
        this.NANOS[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TimeUnit.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('TimeUnit');
  if (this.MILLIS !== null && this.MILLIS !== undefined) {
    output.writeFieldBegin('MILLIS', Thrift.Type.STRUCT, 1);
    this.MILLIS[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.MICROS !== null && this.MICROS !== undefined) {
    output.writeFieldBegin('MICROS', Thrift.Type.STRUCT, 2);
    this.MICROS[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.NANOS !== null && this.NANOS !== undefined) {
    output.writeFieldBegin('NANOS', Thrift.Type.STRUCT, 3);
    this.NANOS[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TimestampType = module.exports.TimestampType = function(args) {
  this.isAdjustedToUTC = null;
  this.unit = null;
  if (args) {
    if (args.isAdjustedToUTC !== undefined && args.isAdjustedToUTC !== null) {
      this.isAdjustedToUTC = args.isAdjustedToUTC;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field isAdjustedToUTC is unset!');
    }
    if (args.unit !== undefined && args.unit !== null) {
      this.unit = new ttypes.TimeUnit(args.unit);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field unit is unset!');
    }
  }
};
TimestampType.prototype = {};
TimestampType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.isAdjustedToUTC = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.unit = new ttypes.TimeUnit();
        this.unit[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TimestampType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('TimestampType');
  if (this.isAdjustedToUTC !== null && this.isAdjustedToUTC !== undefined) {
    output.writeFieldBegin('isAdjustedToUTC', Thrift.Type.BOOL, 1);
    output.writeBool(this.isAdjustedToUTC);
    output.writeFieldEnd();
  }
  if (this.unit !== null && this.unit !== undefined) {
    output.writeFieldBegin('unit', Thrift.Type.STRUCT, 2);
    this.unit[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TimeType = module.exports.TimeType = function(args) {
  this.isAdjustedToUTC = null;
  this.unit = null;
  if (args) {
    if (args.isAdjustedToUTC !== undefined && args.isAdjustedToUTC !== null) {
      this.isAdjustedToUTC = args.isAdjustedToUTC;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field isAdjustedToUTC is unset!');
    }
    if (args.unit !== undefined && args.unit !== null) {
      this.unit = new ttypes.TimeUnit(args.unit);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field unit is unset!');
    }
  }
};
TimeType.prototype = {};
TimeType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.isAdjustedToUTC = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.unit = new ttypes.TimeUnit();
        this.unit[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TimeType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('TimeType');
  if (this.isAdjustedToUTC !== null && this.isAdjustedToUTC !== undefined) {
    output.writeFieldBegin('isAdjustedToUTC', Thrift.Type.BOOL, 1);
    output.writeBool(this.isAdjustedToUTC);
    output.writeFieldEnd();
  }
  if (this.unit !== null && this.unit !== undefined) {
    output.writeFieldBegin('unit', Thrift.Type.STRUCT, 2);
    this.unit[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var IntType = module.exports.IntType = function(args) {
  this.bitWidth = null;
  this.isSigned = null;
  if (args) {
    if (args.bitWidth !== undefined && args.bitWidth !== null) {
      this.bitWidth = args.bitWidth;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field bitWidth is unset!');
    }
    if (args.isSigned !== undefined && args.isSigned !== null) {
      this.isSigned = args.isSigned;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field isSigned is unset!');
    }
  }
};
IntType.prototype = {};
IntType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BYTE) {
        this.bitWidth = input.readByte();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.isSigned = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

IntType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('IntType');
  if (this.bitWidth !== null && this.bitWidth !== undefined) {
    output.writeFieldBegin('bitWidth', Thrift.Type.BYTE, 1);
    output.writeByte(this.bitWidth);
    output.writeFieldEnd();
  }
  if (this.isSigned !== null && this.isSigned !== undefined) {
    output.writeFieldBegin('isSigned', Thrift.Type.BOOL, 2);
    output.writeBool(this.isSigned);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var JsonType = module.exports.JsonType = function(args) {
};
JsonType.prototype = {};
JsonType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

JsonType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('JsonType');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var BsonType = module.exports.BsonType = function(args) {
};
BsonType.prototype = {};
BsonType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BsonType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('BsonType');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var VariantType = module.exports.VariantType = function(args) {
  this.specification_version = null;
  if (args) {
    if (args.specification_version !== undefined && args.specification_version !== null) {
      this.specification_version = args.specification_version;
    }
  }
};
VariantType.prototype = {};
VariantType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BYTE) {
        this.specification_version = input.readByte();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

VariantType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('VariantType');
  if (this.specification_version !== null && this.specification_version !== undefined) {
    output.writeFieldBegin('specification_version', Thrift.Type.BYTE, 1);
    output.writeByte(this.specification_version);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var GeometryType = module.exports.GeometryType = function(args) {
  this.crs = null;
  if (args) {
    if (args.crs !== undefined && args.crs !== null) {
      this.crs = args.crs;
    }
  }
};
GeometryType.prototype = {};
GeometryType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.crs = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GeometryType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('GeometryType');
  if (this.crs !== null && this.crs !== undefined) {
    output.writeFieldBegin('crs', Thrift.Type.STRING, 1);
    output.writeString(this.crs);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var GeographyType = module.exports.GeographyType = function(args) {
  this.crs = null;
  this.algorithm = null;
  if (args) {
    if (args.crs !== undefined && args.crs !== null) {
      this.crs = args.crs;
    }
    if (args.algorithm !== undefined && args.algorithm !== null) {
      this.algorithm = args.algorithm;
    }
  }
};
GeographyType.prototype = {};
GeographyType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.crs = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.algorithm = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GeographyType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('GeographyType');
  if (this.crs !== null && this.crs !== undefined) {
    output.writeFieldBegin('crs', Thrift.Type.STRING, 1);
    output.writeString(this.crs);
    output.writeFieldEnd();
  }
  if (this.algorithm !== null && this.algorithm !== undefined) {
    output.writeFieldBegin('algorithm', Thrift.Type.I32, 2);
    output.writeI32(this.algorithm);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var LogicalType = module.exports.LogicalType = function(args) {
  this.STRING = null;
  this.MAP = null;
  this.LIST = null;
  this.ENUM = null;
  this.DECIMAL = null;
  this.DATE = null;
  this.TIME = null;
  this.TIMESTAMP = null;
  this.INTEGER = null;
  this.UNKNOWN = null;
  this.JSON = null;
  this.BSON = null;
  this.UUID = null;
  this.FLOAT16 = null;
  this.VARIANT = null;
  this.GEOMETRY = null;
  this.GEOGRAPHY = null;
  if (args) {
    if (args.STRING !== undefined && args.STRING !== null) {
      this.STRING = new ttypes.StringType(args.STRING);
    }
    if (args.MAP !== undefined && args.MAP !== null) {
      this.MAP = new ttypes.MapType(args.MAP);
    }
    if (args.LIST !== undefined && args.LIST !== null) {
      this.LIST = new ttypes.ListType(args.LIST);
    }
    if (args.ENUM !== undefined && args.ENUM !== null) {
      this.ENUM = new ttypes.EnumType(args.ENUM);
    }
    if (args.DECIMAL !== undefined && args.DECIMAL !== null) {
      this.DECIMAL = new ttypes.DecimalType(args.DECIMAL);
    }
    if (args.DATE !== undefined && args.DATE !== null) {
      this.DATE = new ttypes.DateType(args.DATE);
    }
    if (args.TIME !== undefined && args.TIME !== null) {
      this.TIME = new ttypes.TimeType(args.TIME);
    }
    if (args.TIMESTAMP !== undefined && args.TIMESTAMP !== null) {
      this.TIMESTAMP = new ttypes.TimestampType(args.TIMESTAMP);
    }
    if (args.INTEGER !== undefined && args.INTEGER !== null) {
      this.INTEGER = new ttypes.IntType(args.INTEGER);
    }
    if (args.UNKNOWN !== undefined && args.UNKNOWN !== null) {
      this.UNKNOWN = new ttypes.NullType(args.UNKNOWN);
    }
    if (args.JSON !== undefined && args.JSON !== null) {
      this.JSON = new ttypes.JsonType(args.JSON);
    }
    if (args.BSON !== undefined && args.BSON !== null) {
      this.BSON = new ttypes.BsonType(args.BSON);
    }
    if (args.UUID !== undefined && args.UUID !== null) {
      this.UUID = new ttypes.UUIDType(args.UUID);
    }
    if (args.FLOAT16 !== undefined && args.FLOAT16 !== null) {
      this.FLOAT16 = new ttypes.Float16Type(args.FLOAT16);
    }
    if (args.VARIANT !== undefined && args.VARIANT !== null) {
      this.VARIANT = new ttypes.VariantType(args.VARIANT);
    }
    if (args.GEOMETRY !== undefined && args.GEOMETRY !== null) {
      this.GEOMETRY = new ttypes.GeometryType(args.GEOMETRY);
    }
    if (args.GEOGRAPHY !== undefined && args.GEOGRAPHY !== null) {
      this.GEOGRAPHY = new ttypes.GeographyType(args.GEOGRAPHY);
    }
  }
};
LogicalType.prototype = {};
LogicalType.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.STRING = new ttypes.StringType();
        this.STRING[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.MAP = new ttypes.MapType();
        this.MAP[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.LIST = new ttypes.ListType();
        this.LIST[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.ENUM = new ttypes.EnumType();
        this.ENUM[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.DECIMAL = new ttypes.DecimalType();
        this.DECIMAL[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRUCT) {
        this.DATE = new ttypes.DateType();
        this.DATE[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRUCT) {
        this.TIME = new ttypes.TimeType();
        this.TIME[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.TIMESTAMP = new ttypes.TimestampType();
        this.TIMESTAMP[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.STRUCT) {
        this.INTEGER = new ttypes.IntType();
        this.INTEGER[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.STRUCT) {
        this.UNKNOWN = new ttypes.NullType();
        this.UNKNOWN[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.STRUCT) {
        this.JSON = new ttypes.JsonType();
        this.JSON[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 13:
      if (ftype == Thrift.Type.STRUCT) {
        this.BSON = new ttypes.BsonType();
        this.BSON[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 14:
      if (ftype == Thrift.Type.STRUCT) {
        this.UUID = new ttypes.UUIDType();
        this.UUID[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 15:
      if (ftype == Thrift.Type.STRUCT) {
        this.FLOAT16 = new ttypes.Float16Type();
        this.FLOAT16[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 16:
      if (ftype == Thrift.Type.STRUCT) {
        this.VARIANT = new ttypes.VariantType();
        this.VARIANT[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 17:
      if (ftype == Thrift.Type.STRUCT) {
        this.GEOMETRY = new ttypes.GeometryType();
        this.GEOMETRY[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 18:
      if (ftype == Thrift.Type.STRUCT) {
        this.GEOGRAPHY = new ttypes.GeographyType();
        this.GEOGRAPHY[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

LogicalType.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('LogicalType');
  if (this.STRING !== null && this.STRING !== undefined) {
    output.writeFieldBegin('STRING', Thrift.Type.STRUCT, 1);
    this.STRING[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.MAP !== null && this.MAP !== undefined) {
    output.writeFieldBegin('MAP', Thrift.Type.STRUCT, 2);
    this.MAP[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.LIST !== null && this.LIST !== undefined) {
    output.writeFieldBegin('LIST', Thrift.Type.STRUCT, 3);
    this.LIST[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.ENUM !== null && this.ENUM !== undefined) {
    output.writeFieldBegin('ENUM', Thrift.Type.STRUCT, 4);
    this.ENUM[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.DECIMAL !== null && this.DECIMAL !== undefined) {
    output.writeFieldBegin('DECIMAL', Thrift.Type.STRUCT, 5);
    this.DECIMAL[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.DATE !== null && this.DATE !== undefined) {
    output.writeFieldBegin('DATE', Thrift.Type.STRUCT, 6);
    this.DATE[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.TIME !== null && this.TIME !== undefined) {
    output.writeFieldBegin('TIME', Thrift.Type.STRUCT, 7);
    this.TIME[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.TIMESTAMP !== null && this.TIMESTAMP !== undefined) {
    output.writeFieldBegin('TIMESTAMP', Thrift.Type.STRUCT, 8);
    this.TIMESTAMP[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.INTEGER !== null && this.INTEGER !== undefined) {
    output.writeFieldBegin('INTEGER', Thrift.Type.STRUCT, 10);
    this.INTEGER[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.UNKNOWN !== null && this.UNKNOWN !== undefined) {
    output.writeFieldBegin('UNKNOWN', Thrift.Type.STRUCT, 11);
    this.UNKNOWN[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.JSON !== null && this.JSON !== undefined) {
    output.writeFieldBegin('JSON', Thrift.Type.STRUCT, 12);
    this.JSON[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.BSON !== null && this.BSON !== undefined) {
    output.writeFieldBegin('BSON', Thrift.Type.STRUCT, 13);
    this.BSON[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.UUID !== null && this.UUID !== undefined) {
    output.writeFieldBegin('UUID', Thrift.Type.STRUCT, 14);
    this.UUID[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.FLOAT16 !== null && this.FLOAT16 !== undefined) {
    output.writeFieldBegin('FLOAT16', Thrift.Type.STRUCT, 15);
    this.FLOAT16[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.VARIANT !== null && this.VARIANT !== undefined) {
    output.writeFieldBegin('VARIANT', Thrift.Type.STRUCT, 16);
    this.VARIANT[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.GEOMETRY !== null && this.GEOMETRY !== undefined) {
    output.writeFieldBegin('GEOMETRY', Thrift.Type.STRUCT, 17);
    this.GEOMETRY[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.GEOGRAPHY !== null && this.GEOGRAPHY !== undefined) {
    output.writeFieldBegin('GEOGRAPHY', Thrift.Type.STRUCT, 18);
    this.GEOGRAPHY[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var SchemaElement = module.exports.SchemaElement = function(args) {
  this.type = null;
  this.type_length = null;
  this.repetition_type = null;
  this.name = null;
  this.num_children = null;
  this.converted_type = null;
  this.scale = null;
  this.precision = null;
  this.field_id = null;
  this.logicalType = null;
  if (args) {
    if (args.type !== undefined && args.type !== null) {
      this.type = args.type;
    }
    if (args.type_length !== undefined && args.type_length !== null) {
      this.type_length = args.type_length;
    }
    if (args.repetition_type !== undefined && args.repetition_type !== null) {
      this.repetition_type = args.repetition_type;
    }
    if (args.name !== undefined && args.name !== null) {
      this.name = args.name;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field name is unset!');
    }
    if (args.num_children !== undefined && args.num_children !== null) {
      this.num_children = args.num_children;
    }
    if (args.converted_type !== undefined && args.converted_type !== null) {
      this.converted_type = args.converted_type;
    }
    if (args.scale !== undefined && args.scale !== null) {
      this.scale = args.scale;
    }
    if (args.precision !== undefined && args.precision !== null) {
      this.precision = args.precision;
    }
    if (args.field_id !== undefined && args.field_id !== null) {
      this.field_id = args.field_id;
    }
    if (args.logicalType !== undefined && args.logicalType !== null) {
      this.logicalType = new ttypes.LogicalType(args.logicalType);
    }
  }
};
SchemaElement.prototype = {};
SchemaElement.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.type_length = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.repetition_type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.num_children = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I32) {
        this.converted_type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I32) {
        this.scale = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I32) {
        this.precision = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.I32) {
        this.field_id = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.STRUCT) {
        this.logicalType = new ttypes.LogicalType();
        this.logicalType[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SchemaElement.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('SchemaElement');
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 1);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  if (this.type_length !== null && this.type_length !== undefined) {
    output.writeFieldBegin('type_length', Thrift.Type.I32, 2);
    output.writeI32(this.type_length);
    output.writeFieldEnd();
  }
  if (this.repetition_type !== null && this.repetition_type !== undefined) {
    output.writeFieldBegin('repetition_type', Thrift.Type.I32, 3);
    output.writeI32(this.repetition_type);
    output.writeFieldEnd();
  }
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 4);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.num_children !== null && this.num_children !== undefined) {
    output.writeFieldBegin('num_children', Thrift.Type.I32, 5);
    output.writeI32(this.num_children);
    output.writeFieldEnd();
  }
  if (this.converted_type !== null && this.converted_type !== undefined) {
    output.writeFieldBegin('converted_type', Thrift.Type.I32, 6);
    output.writeI32(this.converted_type);
    output.writeFieldEnd();
  }
  if (this.scale !== null && this.scale !== undefined) {
    output.writeFieldBegin('scale', Thrift.Type.I32, 7);
    output.writeI32(this.scale);
    output.writeFieldEnd();
  }
  if (this.precision !== null && this.precision !== undefined) {
    output.writeFieldBegin('precision', Thrift.Type.I32, 8);
    output.writeI32(this.precision);
    output.writeFieldEnd();
  }
  if (this.field_id !== null && this.field_id !== undefined) {
    output.writeFieldBegin('field_id', Thrift.Type.I32, 9);
    output.writeI32(this.field_id);
    output.writeFieldEnd();
  }
  if (this.logicalType !== null && this.logicalType !== undefined) {
    output.writeFieldBegin('logicalType', Thrift.Type.STRUCT, 10);
    this.logicalType[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var DataPageHeader = module.exports.DataPageHeader = function(args) {
  this.num_values = null;
  this.encoding = null;
  this.definition_level_encoding = null;
  this.repetition_level_encoding = null;
  this.statistics = null;
  if (args) {
    if (args.num_values !== undefined && args.num_values !== null) {
      this.num_values = args.num_values;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_values is unset!');
    }
    if (args.encoding !== undefined && args.encoding !== null) {
      this.encoding = args.encoding;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encoding is unset!');
    }
    if (args.definition_level_encoding !== undefined && args.definition_level_encoding !== null) {
      this.definition_level_encoding = args.definition_level_encoding;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field definition_level_encoding is unset!');
    }
    if (args.repetition_level_encoding !== undefined && args.repetition_level_encoding !== null) {
      this.repetition_level_encoding = args.repetition_level_encoding;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field repetition_level_encoding is unset!');
    }
    if (args.statistics !== undefined && args.statistics !== null) {
      this.statistics = new ttypes.Statistics(args.statistics);
    }
  }
};
DataPageHeader.prototype = {};
DataPageHeader.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.num_values = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.encoding = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.definition_level_encoding = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.repetition_level_encoding = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.statistics = new ttypes.Statistics();
        this.statistics[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

DataPageHeader.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('DataPageHeader');
  if (this.num_values !== null && this.num_values !== undefined) {
    output.writeFieldBegin('num_values', Thrift.Type.I32, 1);
    output.writeI32(this.num_values);
    output.writeFieldEnd();
  }
  if (this.encoding !== null && this.encoding !== undefined) {
    output.writeFieldBegin('encoding', Thrift.Type.I32, 2);
    output.writeI32(this.encoding);
    output.writeFieldEnd();
  }
  if (this.definition_level_encoding !== null && this.definition_level_encoding !== undefined) {
    output.writeFieldBegin('definition_level_encoding', Thrift.Type.I32, 3);
    output.writeI32(this.definition_level_encoding);
    output.writeFieldEnd();
  }
  if (this.repetition_level_encoding !== null && this.repetition_level_encoding !== undefined) {
    output.writeFieldBegin('repetition_level_encoding', Thrift.Type.I32, 4);
    output.writeI32(this.repetition_level_encoding);
    output.writeFieldEnd();
  }
  if (this.statistics !== null && this.statistics !== undefined) {
    output.writeFieldBegin('statistics', Thrift.Type.STRUCT, 5);
    this.statistics[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var IndexPageHeader = module.exports.IndexPageHeader = function(args) {
};
IndexPageHeader.prototype = {};
IndexPageHeader.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

IndexPageHeader.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('IndexPageHeader');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var DictionaryPageHeader = module.exports.DictionaryPageHeader = function(args) {
  this.num_values = null;
  this.encoding = null;
  this.is_sorted = null;
  if (args) {
    if (args.num_values !== undefined && args.num_values !== null) {
      this.num_values = args.num_values;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_values is unset!');
    }
    if (args.encoding !== undefined && args.encoding !== null) {
      this.encoding = args.encoding;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encoding is unset!');
    }
    if (args.is_sorted !== undefined && args.is_sorted !== null) {
      this.is_sorted = args.is_sorted;
    }
  }
};
DictionaryPageHeader.prototype = {};
DictionaryPageHeader.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.num_values = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.encoding = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.is_sorted = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

DictionaryPageHeader.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('DictionaryPageHeader');
  if (this.num_values !== null && this.num_values !== undefined) {
    output.writeFieldBegin('num_values', Thrift.Type.I32, 1);
    output.writeI32(this.num_values);
    output.writeFieldEnd();
  }
  if (this.encoding !== null && this.encoding !== undefined) {
    output.writeFieldBegin('encoding', Thrift.Type.I32, 2);
    output.writeI32(this.encoding);
    output.writeFieldEnd();
  }
  if (this.is_sorted !== null && this.is_sorted !== undefined) {
    output.writeFieldBegin('is_sorted', Thrift.Type.BOOL, 3);
    output.writeBool(this.is_sorted);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var DataPageHeaderV2 = module.exports.DataPageHeaderV2 = function(args) {
  this.num_values = null;
  this.num_nulls = null;
  this.num_rows = null;
  this.encoding = null;
  this.definition_levels_byte_length = null;
  this.repetition_levels_byte_length = null;
  this.is_compressed = true;
  this.statistics = null;
  if (args) {
    if (args.num_values !== undefined && args.num_values !== null) {
      this.num_values = args.num_values;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_values is unset!');
    }
    if (args.num_nulls !== undefined && args.num_nulls !== null) {
      this.num_nulls = args.num_nulls;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_nulls is unset!');
    }
    if (args.num_rows !== undefined && args.num_rows !== null) {
      this.num_rows = args.num_rows;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_rows is unset!');
    }
    if (args.encoding !== undefined && args.encoding !== null) {
      this.encoding = args.encoding;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encoding is unset!');
    }
    if (args.definition_levels_byte_length !== undefined && args.definition_levels_byte_length !== null) {
      this.definition_levels_byte_length = args.definition_levels_byte_length;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field definition_levels_byte_length is unset!');
    }
    if (args.repetition_levels_byte_length !== undefined && args.repetition_levels_byte_length !== null) {
      this.repetition_levels_byte_length = args.repetition_levels_byte_length;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field repetition_levels_byte_length is unset!');
    }
    if (args.is_compressed !== undefined && args.is_compressed !== null) {
      this.is_compressed = args.is_compressed;
    }
    if (args.statistics !== undefined && args.statistics !== null) {
      this.statistics = new ttypes.Statistics(args.statistics);
    }
  }
};
DataPageHeaderV2.prototype = {};
DataPageHeaderV2.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.num_values = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.num_nulls = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.num_rows = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.encoding = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.definition_levels_byte_length = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I32) {
        this.repetition_levels_byte_length = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.BOOL) {
        this.is_compressed = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.statistics = new ttypes.Statistics();
        this.statistics[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

DataPageHeaderV2.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('DataPageHeaderV2');
  if (this.num_values !== null && this.num_values !== undefined) {
    output.writeFieldBegin('num_values', Thrift.Type.I32, 1);
    output.writeI32(this.num_values);
    output.writeFieldEnd();
  }
  if (this.num_nulls !== null && this.num_nulls !== undefined) {
    output.writeFieldBegin('num_nulls', Thrift.Type.I32, 2);
    output.writeI32(this.num_nulls);
    output.writeFieldEnd();
  }
  if (this.num_rows !== null && this.num_rows !== undefined) {
    output.writeFieldBegin('num_rows', Thrift.Type.I32, 3);
    output.writeI32(this.num_rows);
    output.writeFieldEnd();
  }
  if (this.encoding !== null && this.encoding !== undefined) {
    output.writeFieldBegin('encoding', Thrift.Type.I32, 4);
    output.writeI32(this.encoding);
    output.writeFieldEnd();
  }
  if (this.definition_levels_byte_length !== null && this.definition_levels_byte_length !== undefined) {
    output.writeFieldBegin('definition_levels_byte_length', Thrift.Type.I32, 5);
    output.writeI32(this.definition_levels_byte_length);
    output.writeFieldEnd();
  }
  if (this.repetition_levels_byte_length !== null && this.repetition_levels_byte_length !== undefined) {
    output.writeFieldBegin('repetition_levels_byte_length', Thrift.Type.I32, 6);
    output.writeI32(this.repetition_levels_byte_length);
    output.writeFieldEnd();
  }
  if (this.is_compressed !== null && this.is_compressed !== undefined) {
    output.writeFieldBegin('is_compressed', Thrift.Type.BOOL, 7);
    output.writeBool(this.is_compressed);
    output.writeFieldEnd();
  }
  if (this.statistics !== null && this.statistics !== undefined) {
    output.writeFieldBegin('statistics', Thrift.Type.STRUCT, 8);
    this.statistics[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var SplitBlockAlgorithm = module.exports.SplitBlockAlgorithm = function(args) {
};
SplitBlockAlgorithm.prototype = {};
SplitBlockAlgorithm.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SplitBlockAlgorithm.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('SplitBlockAlgorithm');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var BloomFilterAlgorithm = module.exports.BloomFilterAlgorithm = function(args) {
  this.BLOCK = null;
  if (args) {
    if (args.BLOCK !== undefined && args.BLOCK !== null) {
      this.BLOCK = new ttypes.SplitBlockAlgorithm(args.BLOCK);
    }
  }
};
BloomFilterAlgorithm.prototype = {};
BloomFilterAlgorithm.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.BLOCK = new ttypes.SplitBlockAlgorithm();
        this.BLOCK[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BloomFilterAlgorithm.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('BloomFilterAlgorithm');
  if (this.BLOCK !== null && this.BLOCK !== undefined) {
    output.writeFieldBegin('BLOCK', Thrift.Type.STRUCT, 1);
    this.BLOCK[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var XxHash = module.exports.XxHash = function(args) {
};
XxHash.prototype = {};
XxHash.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XxHash.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('XxHash');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var BloomFilterHash = module.exports.BloomFilterHash = function(args) {
  this.XXHASH = null;
  if (args) {
    if (args.XXHASH !== undefined && args.XXHASH !== null) {
      this.XXHASH = new ttypes.XxHash(args.XXHASH);
    }
  }
};
BloomFilterHash.prototype = {};
BloomFilterHash.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.XXHASH = new ttypes.XxHash();
        this.XXHASH[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BloomFilterHash.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('BloomFilterHash');
  if (this.XXHASH !== null && this.XXHASH !== undefined) {
    output.writeFieldBegin('XXHASH', Thrift.Type.STRUCT, 1);
    this.XXHASH[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Uncompressed = module.exports.Uncompressed = function(args) {
};
Uncompressed.prototype = {};
Uncompressed.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Uncompressed.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('Uncompressed');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var BloomFilterCompression = module.exports.BloomFilterCompression = function(args) {
  this.UNCOMPRESSED = null;
  if (args) {
    if (args.UNCOMPRESSED !== undefined && args.UNCOMPRESSED !== null) {
      this.UNCOMPRESSED = new ttypes.Uncompressed(args.UNCOMPRESSED);
    }
  }
};
BloomFilterCompression.prototype = {};
BloomFilterCompression.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.UNCOMPRESSED = new ttypes.Uncompressed();
        this.UNCOMPRESSED[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BloomFilterCompression.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('BloomFilterCompression');
  if (this.UNCOMPRESSED !== null && this.UNCOMPRESSED !== undefined) {
    output.writeFieldBegin('UNCOMPRESSED', Thrift.Type.STRUCT, 1);
    this.UNCOMPRESSED[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var BloomFilterHeader = module.exports.BloomFilterHeader = function(args) {
  this.numBytes = null;
  this.algorithm = null;
  this.hash = null;
  this.compression = null;
  if (args) {
    if (args.numBytes !== undefined && args.numBytes !== null) {
      this.numBytes = args.numBytes;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field numBytes is unset!');
    }
    if (args.algorithm !== undefined && args.algorithm !== null) {
      this.algorithm = new ttypes.BloomFilterAlgorithm(args.algorithm);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field algorithm is unset!');
    }
    if (args.hash !== undefined && args.hash !== null) {
      this.hash = new ttypes.BloomFilterHash(args.hash);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field hash is unset!');
    }
    if (args.compression !== undefined && args.compression !== null) {
      this.compression = new ttypes.BloomFilterCompression(args.compression);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field compression is unset!');
    }
  }
};
BloomFilterHeader.prototype = {};
BloomFilterHeader.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.numBytes = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.algorithm = new ttypes.BloomFilterAlgorithm();
        this.algorithm[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.hash = new ttypes.BloomFilterHash();
        this.hash[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.compression = new ttypes.BloomFilterCompression();
        this.compression[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BloomFilterHeader.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('BloomFilterHeader');
  if (this.numBytes !== null && this.numBytes !== undefined) {
    output.writeFieldBegin('numBytes', Thrift.Type.I32, 1);
    output.writeI32(this.numBytes);
    output.writeFieldEnd();
  }
  if (this.algorithm !== null && this.algorithm !== undefined) {
    output.writeFieldBegin('algorithm', Thrift.Type.STRUCT, 2);
    this.algorithm[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.hash !== null && this.hash !== undefined) {
    output.writeFieldBegin('hash', Thrift.Type.STRUCT, 3);
    this.hash[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.compression !== null && this.compression !== undefined) {
    output.writeFieldBegin('compression', Thrift.Type.STRUCT, 4);
    this.compression[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var PageHeader = module.exports.PageHeader = function(args) {
  this.type = null;
  this.uncompressed_page_size = null;
  this.compressed_page_size = null;
  this.crc = null;
  this.data_page_header = null;
  this.index_page_header = null;
  this.dictionary_page_header = null;
  this.data_page_header_v2 = null;
  if (args) {
    if (args.type !== undefined && args.type !== null) {
      this.type = args.type;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field type is unset!');
    }
    if (args.uncompressed_page_size !== undefined && args.uncompressed_page_size !== null) {
      this.uncompressed_page_size = args.uncompressed_page_size;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field uncompressed_page_size is unset!');
    }
    if (args.compressed_page_size !== undefined && args.compressed_page_size !== null) {
      this.compressed_page_size = args.compressed_page_size;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field compressed_page_size is unset!');
    }
    if (args.crc !== undefined && args.crc !== null) {
      this.crc = args.crc;
    }
    if (args.data_page_header !== undefined && args.data_page_header !== null) {
      this.data_page_header = new ttypes.DataPageHeader(args.data_page_header);
    }
    if (args.index_page_header !== undefined && args.index_page_header !== null) {
      this.index_page_header = new ttypes.IndexPageHeader(args.index_page_header);
    }
    if (args.dictionary_page_header !== undefined && args.dictionary_page_header !== null) {
      this.dictionary_page_header = new ttypes.DictionaryPageHeader(args.dictionary_page_header);
    }
    if (args.data_page_header_v2 !== undefined && args.data_page_header_v2 !== null) {
      this.data_page_header_v2 = new ttypes.DataPageHeaderV2(args.data_page_header_v2);
    }
  }
};
PageHeader.prototype = {};
PageHeader.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.uncompressed_page_size = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.compressed_page_size = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.crc = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.data_page_header = new ttypes.DataPageHeader();
        this.data_page_header[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRUCT) {
        this.index_page_header = new ttypes.IndexPageHeader();
        this.index_page_header[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRUCT) {
        this.dictionary_page_header = new ttypes.DictionaryPageHeader();
        this.dictionary_page_header[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.data_page_header_v2 = new ttypes.DataPageHeaderV2();
        this.data_page_header_v2[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

PageHeader.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('PageHeader');
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 1);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  if (this.uncompressed_page_size !== null && this.uncompressed_page_size !== undefined) {
    output.writeFieldBegin('uncompressed_page_size', Thrift.Type.I32, 2);
    output.writeI32(this.uncompressed_page_size);
    output.writeFieldEnd();
  }
  if (this.compressed_page_size !== null && this.compressed_page_size !== undefined) {
    output.writeFieldBegin('compressed_page_size', Thrift.Type.I32, 3);
    output.writeI32(this.compressed_page_size);
    output.writeFieldEnd();
  }
  if (this.crc !== null && this.crc !== undefined) {
    output.writeFieldBegin('crc', Thrift.Type.I32, 4);
    output.writeI32(this.crc);
    output.writeFieldEnd();
  }
  if (this.data_page_header !== null && this.data_page_header !== undefined) {
    output.writeFieldBegin('data_page_header', Thrift.Type.STRUCT, 5);
    this.data_page_header[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.index_page_header !== null && this.index_page_header !== undefined) {
    output.writeFieldBegin('index_page_header', Thrift.Type.STRUCT, 6);
    this.index_page_header[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.dictionary_page_header !== null && this.dictionary_page_header !== undefined) {
    output.writeFieldBegin('dictionary_page_header', Thrift.Type.STRUCT, 7);
    this.dictionary_page_header[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.data_page_header_v2 !== null && this.data_page_header_v2 !== undefined) {
    output.writeFieldBegin('data_page_header_v2', Thrift.Type.STRUCT, 8);
    this.data_page_header_v2[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var KeyValue = module.exports.KeyValue = function(args) {
  this.key = null;
  this.value = null;
  if (args) {
    if (args.key !== undefined && args.key !== null) {
      this.key = args.key;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field key is unset!');
    }
    if (args.value !== undefined && args.value !== null) {
      this.value = args.value;
    }
  }
};
KeyValue.prototype = {};
KeyValue.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.value = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

KeyValue.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('KeyValue');
  if (this.key !== null && this.key !== undefined) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.value !== null && this.value !== undefined) {
    output.writeFieldBegin('value', Thrift.Type.STRING, 2);
    output.writeString(this.value);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var SortingColumn = module.exports.SortingColumn = function(args) {
  this.column_idx = null;
  this.descending = null;
  this.nulls_first = null;
  if (args) {
    if (args.column_idx !== undefined && args.column_idx !== null) {
      this.column_idx = args.column_idx;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field column_idx is unset!');
    }
    if (args.descending !== undefined && args.descending !== null) {
      this.descending = args.descending;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field descending is unset!');
    }
    if (args.nulls_first !== undefined && args.nulls_first !== null) {
      this.nulls_first = args.nulls_first;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field nulls_first is unset!');
    }
  }
};
SortingColumn.prototype = {};
SortingColumn.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.column_idx = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.descending = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.nulls_first = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SortingColumn.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('SortingColumn');
  if (this.column_idx !== null && this.column_idx !== undefined) {
    output.writeFieldBegin('column_idx', Thrift.Type.I32, 1);
    output.writeI32(this.column_idx);
    output.writeFieldEnd();
  }
  if (this.descending !== null && this.descending !== undefined) {
    output.writeFieldBegin('descending', Thrift.Type.BOOL, 2);
    output.writeBool(this.descending);
    output.writeFieldEnd();
  }
  if (this.nulls_first !== null && this.nulls_first !== undefined) {
    output.writeFieldBegin('nulls_first', Thrift.Type.BOOL, 3);
    output.writeBool(this.nulls_first);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var PageEncodingStats = module.exports.PageEncodingStats = function(args) {
  this.page_type = null;
  this.encoding = null;
  this.count = null;
  if (args) {
    if (args.page_type !== undefined && args.page_type !== null) {
      this.page_type = args.page_type;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field page_type is unset!');
    }
    if (args.encoding !== undefined && args.encoding !== null) {
      this.encoding = args.encoding;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encoding is unset!');
    }
    if (args.count !== undefined && args.count !== null) {
      this.count = args.count;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field count is unset!');
    }
  }
};
PageEncodingStats.prototype = {};
PageEncodingStats.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.page_type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.encoding = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.count = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

PageEncodingStats.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('PageEncodingStats');
  if (this.page_type !== null && this.page_type !== undefined) {
    output.writeFieldBegin('page_type', Thrift.Type.I32, 1);
    output.writeI32(this.page_type);
    output.writeFieldEnd();
  }
  if (this.encoding !== null && this.encoding !== undefined) {
    output.writeFieldBegin('encoding', Thrift.Type.I32, 2);
    output.writeI32(this.encoding);
    output.writeFieldEnd();
  }
  if (this.count !== null && this.count !== undefined) {
    output.writeFieldBegin('count', Thrift.Type.I32, 3);
    output.writeI32(this.count);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ColumnMetaData = module.exports.ColumnMetaData = function(args) {
  this.type = null;
  this.encodings = null;
  this.path_in_schema = null;
  this.codec = null;
  this.num_values = null;
  this.total_uncompressed_size = null;
  this.total_compressed_size = null;
  this.key_value_metadata = null;
  this.data_page_offset = null;
  this.index_page_offset = null;
  this.dictionary_page_offset = null;
  this.statistics = null;
  this.encoding_stats = null;
  this.bloom_filter_offset = null;
  this.bloom_filter_length = null;
  this.size_statistics = null;
  this.geospatial_statistics = null;
  if (args) {
    if (args.type !== undefined && args.type !== null) {
      this.type = args.type;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field type is unset!');
    }
    if (args.encodings !== undefined && args.encodings !== null) {
      this.encodings = Thrift.copyList(args.encodings, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encodings is unset!');
    }
    if (args.path_in_schema !== undefined && args.path_in_schema !== null) {
      this.path_in_schema = Thrift.copyList(args.path_in_schema, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field path_in_schema is unset!');
    }
    if (args.codec !== undefined && args.codec !== null) {
      this.codec = args.codec;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field codec is unset!');
    }
    if (args.num_values !== undefined && args.num_values !== null) {
      this.num_values = args.num_values;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_values is unset!');
    }
    if (args.total_uncompressed_size !== undefined && args.total_uncompressed_size !== null) {
      this.total_uncompressed_size = args.total_uncompressed_size;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field total_uncompressed_size is unset!');
    }
    if (args.total_compressed_size !== undefined && args.total_compressed_size !== null) {
      this.total_compressed_size = args.total_compressed_size;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field total_compressed_size is unset!');
    }
    if (args.key_value_metadata !== undefined && args.key_value_metadata !== null) {
      this.key_value_metadata = Thrift.copyList(args.key_value_metadata, [ttypes.KeyValue]);
    }
    if (args.data_page_offset !== undefined && args.data_page_offset !== null) {
      this.data_page_offset = args.data_page_offset;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field data_page_offset is unset!');
    }
    if (args.index_page_offset !== undefined && args.index_page_offset !== null) {
      this.index_page_offset = args.index_page_offset;
    }
    if (args.dictionary_page_offset !== undefined && args.dictionary_page_offset !== null) {
      this.dictionary_page_offset = args.dictionary_page_offset;
    }
    if (args.statistics !== undefined && args.statistics !== null) {
      this.statistics = new ttypes.Statistics(args.statistics);
    }
    if (args.encoding_stats !== undefined && args.encoding_stats !== null) {
      this.encoding_stats = Thrift.copyList(args.encoding_stats, [ttypes.PageEncodingStats]);
    }
    if (args.bloom_filter_offset !== undefined && args.bloom_filter_offset !== null) {
      this.bloom_filter_offset = args.bloom_filter_offset;
    }
    if (args.bloom_filter_length !== undefined && args.bloom_filter_length !== null) {
      this.bloom_filter_length = args.bloom_filter_length;
    }
    if (args.size_statistics !== undefined && args.size_statistics !== null) {
      this.size_statistics = new ttypes.SizeStatistics(args.size_statistics);
    }
    if (args.geospatial_statistics !== undefined && args.geospatial_statistics !== null) {
      this.geospatial_statistics = new ttypes.GeospatialStatistics(args.geospatial_statistics);
    }
  }
};
ColumnMetaData.prototype = {};
ColumnMetaData.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.encodings = [];
        var _rtmp316 = input.readListBegin();
        var _size15 = _rtmp316.size || 0;
        for (var _i17 = 0; _i17 < _size15; ++_i17) {
          var elem18 = null;
          elem18 = input.readI32();
          this.encodings.push(elem18);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        this.path_in_schema = [];
        var _rtmp320 = input.readListBegin();
        var _size19 = _rtmp320.size || 0;
        for (var _i21 = 0; _i21 < _size19; ++_i21) {
          var elem22 = null;
          elem22 = input.readString();
          this.path_in_schema.push(elem22);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.codec = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.num_values = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I64) {
        this.total_uncompressed_size = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I64) {
        this.total_compressed_size = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.LIST) {
        this.key_value_metadata = [];
        var _rtmp324 = input.readListBegin();
        var _size23 = _rtmp324.size || 0;
        for (var _i25 = 0; _i25 < _size23; ++_i25) {
          var elem26 = null;
          elem26 = new ttypes.KeyValue();
          elem26[Symbol.for("read")](input);
          this.key_value_metadata.push(elem26);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.I64) {
        this.data_page_offset = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.I64) {
        this.index_page_offset = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.I64) {
        this.dictionary_page_offset = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.STRUCT) {
        this.statistics = new ttypes.Statistics();
        this.statistics[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 13:
      if (ftype == Thrift.Type.LIST) {
        this.encoding_stats = [];
        var _rtmp328 = input.readListBegin();
        var _size27 = _rtmp328.size || 0;
        for (var _i29 = 0; _i29 < _size27; ++_i29) {
          var elem30 = null;
          elem30 = new ttypes.PageEncodingStats();
          elem30[Symbol.for("read")](input);
          this.encoding_stats.push(elem30);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 14:
      if (ftype == Thrift.Type.I64) {
        this.bloom_filter_offset = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 15:
      if (ftype == Thrift.Type.I32) {
        this.bloom_filter_length = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 16:
      if (ftype == Thrift.Type.STRUCT) {
        this.size_statistics = new ttypes.SizeStatistics();
        this.size_statistics[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 17:
      if (ftype == Thrift.Type.STRUCT) {
        this.geospatial_statistics = new ttypes.GeospatialStatistics();
        this.geospatial_statistics[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ColumnMetaData.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('ColumnMetaData');
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 1);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  if (this.encodings !== null && this.encodings !== undefined) {
    output.writeFieldBegin('encodings', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.I32, this.encodings.length);
    for (var iter31 in this.encodings) {
      if (this.encodings.hasOwnProperty(iter31)) {
        iter31 = this.encodings[iter31];
        output.writeI32(iter31);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.path_in_schema !== null && this.path_in_schema !== undefined) {
    output.writeFieldBegin('path_in_schema', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRING, this.path_in_schema.length);
    for (var iter32 in this.path_in_schema) {
      if (this.path_in_schema.hasOwnProperty(iter32)) {
        iter32 = this.path_in_schema[iter32];
        output.writeString(iter32);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.codec !== null && this.codec !== undefined) {
    output.writeFieldBegin('codec', Thrift.Type.I32, 4);
    output.writeI32(this.codec);
    output.writeFieldEnd();
  }
  if (this.num_values !== null && this.num_values !== undefined) {
    output.writeFieldBegin('num_values', Thrift.Type.I64, 5);
    output.writeI64(this.num_values);
    output.writeFieldEnd();
  }
  if (this.total_uncompressed_size !== null && this.total_uncompressed_size !== undefined) {
    output.writeFieldBegin('total_uncompressed_size', Thrift.Type.I64, 6);
    output.writeI64(this.total_uncompressed_size);
    output.writeFieldEnd();
  }
  if (this.total_compressed_size !== null && this.total_compressed_size !== undefined) {
    output.writeFieldBegin('total_compressed_size', Thrift.Type.I64, 7);
    output.writeI64(this.total_compressed_size);
    output.writeFieldEnd();
  }
  if (this.key_value_metadata !== null && this.key_value_metadata !== undefined) {
    output.writeFieldBegin('key_value_metadata', Thrift.Type.LIST, 8);
    output.writeListBegin(Thrift.Type.STRUCT, this.key_value_metadata.length);
    for (var iter33 in this.key_value_metadata) {
      if (this.key_value_metadata.hasOwnProperty(iter33)) {
        iter33 = this.key_value_metadata[iter33];
        iter33[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.data_page_offset !== null && this.data_page_offset !== undefined) {
    output.writeFieldBegin('data_page_offset', Thrift.Type.I64, 9);
    output.writeI64(this.data_page_offset);
    output.writeFieldEnd();
  }
  if (this.index_page_offset !== null && this.index_page_offset !== undefined) {
    output.writeFieldBegin('index_page_offset', Thrift.Type.I64, 10);
    output.writeI64(this.index_page_offset);
    output.writeFieldEnd();
  }
  if (this.dictionary_page_offset !== null && this.dictionary_page_offset !== undefined) {
    output.writeFieldBegin('dictionary_page_offset', Thrift.Type.I64, 11);
    output.writeI64(this.dictionary_page_offset);
    output.writeFieldEnd();
  }
  if (this.statistics !== null && this.statistics !== undefined) {
    output.writeFieldBegin('statistics', Thrift.Type.STRUCT, 12);
    this.statistics[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.encoding_stats !== null && this.encoding_stats !== undefined) {
    output.writeFieldBegin('encoding_stats', Thrift.Type.LIST, 13);
    output.writeListBegin(Thrift.Type.STRUCT, this.encoding_stats.length);
    for (var iter34 in this.encoding_stats) {
      if (this.encoding_stats.hasOwnProperty(iter34)) {
        iter34 = this.encoding_stats[iter34];
        iter34[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.bloom_filter_offset !== null && this.bloom_filter_offset !== undefined) {
    output.writeFieldBegin('bloom_filter_offset', Thrift.Type.I64, 14);
    output.writeI64(this.bloom_filter_offset);
    output.writeFieldEnd();
  }
  if (this.bloom_filter_length !== null && this.bloom_filter_length !== undefined) {
    output.writeFieldBegin('bloom_filter_length', Thrift.Type.I32, 15);
    output.writeI32(this.bloom_filter_length);
    output.writeFieldEnd();
  }
  if (this.size_statistics !== null && this.size_statistics !== undefined) {
    output.writeFieldBegin('size_statistics', Thrift.Type.STRUCT, 16);
    this.size_statistics[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.geospatial_statistics !== null && this.geospatial_statistics !== undefined) {
    output.writeFieldBegin('geospatial_statistics', Thrift.Type.STRUCT, 17);
    this.geospatial_statistics[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var EncryptionWithFooterKey = module.exports.EncryptionWithFooterKey = function(args) {
};
EncryptionWithFooterKey.prototype = {};
EncryptionWithFooterKey.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

EncryptionWithFooterKey.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('EncryptionWithFooterKey');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var EncryptionWithColumnKey = module.exports.EncryptionWithColumnKey = function(args) {
  this.path_in_schema = null;
  this.key_metadata = null;
  if (args) {
    if (args.path_in_schema !== undefined && args.path_in_schema !== null) {
      this.path_in_schema = Thrift.copyList(args.path_in_schema, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field path_in_schema is unset!');
    }
    if (args.key_metadata !== undefined && args.key_metadata !== null) {
      this.key_metadata = args.key_metadata;
    }
  }
};
EncryptionWithColumnKey.prototype = {};
EncryptionWithColumnKey.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.path_in_schema = [];
        var _rtmp336 = input.readListBegin();
        var _size35 = _rtmp336.size || 0;
        for (var _i37 = 0; _i37 < _size35; ++_i37) {
          var elem38 = null;
          elem38 = input.readString();
          this.path_in_schema.push(elem38);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.key_metadata = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

EncryptionWithColumnKey.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('EncryptionWithColumnKey');
  if (this.path_in_schema !== null && this.path_in_schema !== undefined) {
    output.writeFieldBegin('path_in_schema', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.path_in_schema.length);
    for (var iter39 in this.path_in_schema) {
      if (this.path_in_schema.hasOwnProperty(iter39)) {
        iter39 = this.path_in_schema[iter39];
        output.writeString(iter39);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.key_metadata !== null && this.key_metadata !== undefined) {
    output.writeFieldBegin('key_metadata', Thrift.Type.STRING, 2);
    output.writeBinary(this.key_metadata);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ColumnCryptoMetaData = module.exports.ColumnCryptoMetaData = function(args) {
  this.ENCRYPTION_WITH_FOOTER_KEY = null;
  this.ENCRYPTION_WITH_COLUMN_KEY = null;
  if (args) {
    if (args.ENCRYPTION_WITH_FOOTER_KEY !== undefined && args.ENCRYPTION_WITH_FOOTER_KEY !== null) {
      this.ENCRYPTION_WITH_FOOTER_KEY = new ttypes.EncryptionWithFooterKey(args.ENCRYPTION_WITH_FOOTER_KEY);
    }
    if (args.ENCRYPTION_WITH_COLUMN_KEY !== undefined && args.ENCRYPTION_WITH_COLUMN_KEY !== null) {
      this.ENCRYPTION_WITH_COLUMN_KEY = new ttypes.EncryptionWithColumnKey(args.ENCRYPTION_WITH_COLUMN_KEY);
    }
  }
};
ColumnCryptoMetaData.prototype = {};
ColumnCryptoMetaData.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ENCRYPTION_WITH_FOOTER_KEY = new ttypes.EncryptionWithFooterKey();
        this.ENCRYPTION_WITH_FOOTER_KEY[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ENCRYPTION_WITH_COLUMN_KEY = new ttypes.EncryptionWithColumnKey();
        this.ENCRYPTION_WITH_COLUMN_KEY[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ColumnCryptoMetaData.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('ColumnCryptoMetaData');
  if (this.ENCRYPTION_WITH_FOOTER_KEY !== null && this.ENCRYPTION_WITH_FOOTER_KEY !== undefined) {
    output.writeFieldBegin('ENCRYPTION_WITH_FOOTER_KEY', Thrift.Type.STRUCT, 1);
    this.ENCRYPTION_WITH_FOOTER_KEY[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.ENCRYPTION_WITH_COLUMN_KEY !== null && this.ENCRYPTION_WITH_COLUMN_KEY !== undefined) {
    output.writeFieldBegin('ENCRYPTION_WITH_COLUMN_KEY', Thrift.Type.STRUCT, 2);
    this.ENCRYPTION_WITH_COLUMN_KEY[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ColumnChunk = module.exports.ColumnChunk = function(args) {
  this.file_path = null;
  this.file_offset = new Int64(0);
  this.meta_data = null;
  this.offset_index_offset = null;
  this.offset_index_length = null;
  this.column_index_offset = null;
  this.column_index_length = null;
  this.crypto_metadata = null;
  this.encrypted_column_metadata = null;
  if (args) {
    if (args.file_path !== undefined && args.file_path !== null) {
      this.file_path = args.file_path;
    }
    if (args.file_offset !== undefined && args.file_offset !== null) {
      this.file_offset = args.file_offset;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field file_offset is unset!');
    }
    if (args.meta_data !== undefined && args.meta_data !== null) {
      this.meta_data = new ttypes.ColumnMetaData(args.meta_data);
    }
    if (args.offset_index_offset !== undefined && args.offset_index_offset !== null) {
      this.offset_index_offset = args.offset_index_offset;
    }
    if (args.offset_index_length !== undefined && args.offset_index_length !== null) {
      this.offset_index_length = args.offset_index_length;
    }
    if (args.column_index_offset !== undefined && args.column_index_offset !== null) {
      this.column_index_offset = args.column_index_offset;
    }
    if (args.column_index_length !== undefined && args.column_index_length !== null) {
      this.column_index_length = args.column_index_length;
    }
    if (args.crypto_metadata !== undefined && args.crypto_metadata !== null) {
      this.crypto_metadata = new ttypes.ColumnCryptoMetaData(args.crypto_metadata);
    }
    if (args.encrypted_column_metadata !== undefined && args.encrypted_column_metadata !== null) {
      this.encrypted_column_metadata = args.encrypted_column_metadata;
    }
  }
};
ColumnChunk.prototype = {};
ColumnChunk.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.file_path = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.file_offset = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.meta_data = new ttypes.ColumnMetaData();
        this.meta_data[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I64) {
        this.offset_index_offset = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.offset_index_length = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I64) {
        this.column_index_offset = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I32) {
        this.column_index_length = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.crypto_metadata = new ttypes.ColumnCryptoMetaData();
        this.crypto_metadata[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.STRING) {
        this.encrypted_column_metadata = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ColumnChunk.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('ColumnChunk');
  if (this.file_path !== null && this.file_path !== undefined) {
    output.writeFieldBegin('file_path', Thrift.Type.STRING, 1);
    output.writeString(this.file_path);
    output.writeFieldEnd();
  }
  if (this.file_offset !== null && this.file_offset !== undefined) {
    output.writeFieldBegin('file_offset', Thrift.Type.I64, 2);
    output.writeI64(this.file_offset);
    output.writeFieldEnd();
  }
  if (this.meta_data !== null && this.meta_data !== undefined) {
    output.writeFieldBegin('meta_data', Thrift.Type.STRUCT, 3);
    this.meta_data[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.offset_index_offset !== null && this.offset_index_offset !== undefined) {
    output.writeFieldBegin('offset_index_offset', Thrift.Type.I64, 4);
    output.writeI64(this.offset_index_offset);
    output.writeFieldEnd();
  }
  if (this.offset_index_length !== null && this.offset_index_length !== undefined) {
    output.writeFieldBegin('offset_index_length', Thrift.Type.I32, 5);
    output.writeI32(this.offset_index_length);
    output.writeFieldEnd();
  }
  if (this.column_index_offset !== null && this.column_index_offset !== undefined) {
    output.writeFieldBegin('column_index_offset', Thrift.Type.I64, 6);
    output.writeI64(this.column_index_offset);
    output.writeFieldEnd();
  }
  if (this.column_index_length !== null && this.column_index_length !== undefined) {
    output.writeFieldBegin('column_index_length', Thrift.Type.I32, 7);
    output.writeI32(this.column_index_length);
    output.writeFieldEnd();
  }
  if (this.crypto_metadata !== null && this.crypto_metadata !== undefined) {
    output.writeFieldBegin('crypto_metadata', Thrift.Type.STRUCT, 8);
    this.crypto_metadata[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.encrypted_column_metadata !== null && this.encrypted_column_metadata !== undefined) {
    output.writeFieldBegin('encrypted_column_metadata', Thrift.Type.STRING, 9);
    output.writeBinary(this.encrypted_column_metadata);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var RowGroup = module.exports.RowGroup = function(args) {
  this.columns = null;
  this.total_byte_size = null;
  this.num_rows = null;
  this.sorting_columns = null;
  this.file_offset = null;
  this.total_compressed_size = null;
  this.ordinal = null;
  if (args) {
    if (args.columns !== undefined && args.columns !== null) {
      this.columns = Thrift.copyList(args.columns, [ttypes.ColumnChunk]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field columns is unset!');
    }
    if (args.total_byte_size !== undefined && args.total_byte_size !== null) {
      this.total_byte_size = args.total_byte_size;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field total_byte_size is unset!');
    }
    if (args.num_rows !== undefined && args.num_rows !== null) {
      this.num_rows = args.num_rows;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_rows is unset!');
    }
    if (args.sorting_columns !== undefined && args.sorting_columns !== null) {
      this.sorting_columns = Thrift.copyList(args.sorting_columns, [ttypes.SortingColumn]);
    }
    if (args.file_offset !== undefined && args.file_offset !== null) {
      this.file_offset = args.file_offset;
    }
    if (args.total_compressed_size !== undefined && args.total_compressed_size !== null) {
      this.total_compressed_size = args.total_compressed_size;
    }
    if (args.ordinal !== undefined && args.ordinal !== null) {
      this.ordinal = args.ordinal;
    }
  }
};
RowGroup.prototype = {};
RowGroup.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.columns = [];
        var _rtmp341 = input.readListBegin();
        var _size40 = _rtmp341.size || 0;
        for (var _i42 = 0; _i42 < _size40; ++_i42) {
          var elem43 = null;
          elem43 = new ttypes.ColumnChunk();
          elem43[Symbol.for("read")](input);
          this.columns.push(elem43);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.total_byte_size = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.num_rows = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        this.sorting_columns = [];
        var _rtmp345 = input.readListBegin();
        var _size44 = _rtmp345.size || 0;
        for (var _i46 = 0; _i46 < _size44; ++_i46) {
          var elem47 = null;
          elem47 = new ttypes.SortingColumn();
          elem47[Symbol.for("read")](input);
          this.sorting_columns.push(elem47);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.file_offset = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I64) {
        this.total_compressed_size = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I16) {
        this.ordinal = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

RowGroup.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('RowGroup');
  if (this.columns !== null && this.columns !== undefined) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
    for (var iter48 in this.columns) {
      if (this.columns.hasOwnProperty(iter48)) {
        iter48 = this.columns[iter48];
        iter48[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.total_byte_size !== null && this.total_byte_size !== undefined) {
    output.writeFieldBegin('total_byte_size', Thrift.Type.I64, 2);
    output.writeI64(this.total_byte_size);
    output.writeFieldEnd();
  }
  if (this.num_rows !== null && this.num_rows !== undefined) {
    output.writeFieldBegin('num_rows', Thrift.Type.I64, 3);
    output.writeI64(this.num_rows);
    output.writeFieldEnd();
  }
  if (this.sorting_columns !== null && this.sorting_columns !== undefined) {
    output.writeFieldBegin('sorting_columns', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.STRUCT, this.sorting_columns.length);
    for (var iter49 in this.sorting_columns) {
      if (this.sorting_columns.hasOwnProperty(iter49)) {
        iter49 = this.sorting_columns[iter49];
        iter49[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.file_offset !== null && this.file_offset !== undefined) {
    output.writeFieldBegin('file_offset', Thrift.Type.I64, 5);
    output.writeI64(this.file_offset);
    output.writeFieldEnd();
  }
  if (this.total_compressed_size !== null && this.total_compressed_size !== undefined) {
    output.writeFieldBegin('total_compressed_size', Thrift.Type.I64, 6);
    output.writeI64(this.total_compressed_size);
    output.writeFieldEnd();
  }
  if (this.ordinal !== null && this.ordinal !== undefined) {
    output.writeFieldBegin('ordinal', Thrift.Type.I16, 7);
    output.writeI16(this.ordinal);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TypeDefinedOrder = module.exports.TypeDefinedOrder = function(args) {
};
TypeDefinedOrder.prototype = {};
TypeDefinedOrder.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TypeDefinedOrder.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('TypeDefinedOrder');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ColumnOrder = module.exports.ColumnOrder = function(args) {
  this.TYPE_ORDER = null;
  if (args) {
    if (args.TYPE_ORDER !== undefined && args.TYPE_ORDER !== null) {
      this.TYPE_ORDER = new ttypes.TypeDefinedOrder(args.TYPE_ORDER);
    }
  }
};
ColumnOrder.prototype = {};
ColumnOrder.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.TYPE_ORDER = new ttypes.TypeDefinedOrder();
        this.TYPE_ORDER[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ColumnOrder.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('ColumnOrder');
  if (this.TYPE_ORDER !== null && this.TYPE_ORDER !== undefined) {
    output.writeFieldBegin('TYPE_ORDER', Thrift.Type.STRUCT, 1);
    this.TYPE_ORDER[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var PageLocation = module.exports.PageLocation = function(args) {
  this.offset = null;
  this.compressed_page_size = null;
  this.first_row_index = null;
  if (args) {
    if (args.offset !== undefined && args.offset !== null) {
      this.offset = args.offset;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field offset is unset!');
    }
    if (args.compressed_page_size !== undefined && args.compressed_page_size !== null) {
      this.compressed_page_size = args.compressed_page_size;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field compressed_page_size is unset!');
    }
    if (args.first_row_index !== undefined && args.first_row_index !== null) {
      this.first_row_index = args.first_row_index;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field first_row_index is unset!');
    }
  }
};
PageLocation.prototype = {};
PageLocation.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.offset = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.compressed_page_size = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.first_row_index = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

PageLocation.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('PageLocation');
  if (this.offset !== null && this.offset !== undefined) {
    output.writeFieldBegin('offset', Thrift.Type.I64, 1);
    output.writeI64(this.offset);
    output.writeFieldEnd();
  }
  if (this.compressed_page_size !== null && this.compressed_page_size !== undefined) {
    output.writeFieldBegin('compressed_page_size', Thrift.Type.I32, 2);
    output.writeI32(this.compressed_page_size);
    output.writeFieldEnd();
  }
  if (this.first_row_index !== null && this.first_row_index !== undefined) {
    output.writeFieldBegin('first_row_index', Thrift.Type.I64, 3);
    output.writeI64(this.first_row_index);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var OffsetIndex = module.exports.OffsetIndex = function(args) {
  this.page_locations = null;
  this.unencoded_byte_array_data_bytes = null;
  if (args) {
    if (args.page_locations !== undefined && args.page_locations !== null) {
      this.page_locations = Thrift.copyList(args.page_locations, [ttypes.PageLocation]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field page_locations is unset!');
    }
    if (args.unencoded_byte_array_data_bytes !== undefined && args.unencoded_byte_array_data_bytes !== null) {
      this.unencoded_byte_array_data_bytes = Thrift.copyList(args.unencoded_byte_array_data_bytes, [null]);
    }
  }
};
OffsetIndex.prototype = {};
OffsetIndex.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.page_locations = [];
        var _rtmp351 = input.readListBegin();
        var _size50 = _rtmp351.size || 0;
        for (var _i52 = 0; _i52 < _size50; ++_i52) {
          var elem53 = null;
          elem53 = new ttypes.PageLocation();
          elem53[Symbol.for("read")](input);
          this.page_locations.push(elem53);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.unencoded_byte_array_data_bytes = [];
        var _rtmp355 = input.readListBegin();
        var _size54 = _rtmp355.size || 0;
        for (var _i56 = 0; _i56 < _size54; ++_i56) {
          var elem57 = null;
          elem57 = input.readI64();
          this.unencoded_byte_array_data_bytes.push(elem57);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

OffsetIndex.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('OffsetIndex');
  if (this.page_locations !== null && this.page_locations !== undefined) {
    output.writeFieldBegin('page_locations', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.page_locations.length);
    for (var iter58 in this.page_locations) {
      if (this.page_locations.hasOwnProperty(iter58)) {
        iter58 = this.page_locations[iter58];
        iter58[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.unencoded_byte_array_data_bytes !== null && this.unencoded_byte_array_data_bytes !== undefined) {
    output.writeFieldBegin('unencoded_byte_array_data_bytes', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.I64, this.unencoded_byte_array_data_bytes.length);
    for (var iter59 in this.unencoded_byte_array_data_bytes) {
      if (this.unencoded_byte_array_data_bytes.hasOwnProperty(iter59)) {
        iter59 = this.unencoded_byte_array_data_bytes[iter59];
        output.writeI64(iter59);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ColumnIndex = module.exports.ColumnIndex = function(args) {
  this.null_pages = null;
  this.min_values = null;
  this.max_values = null;
  this.boundary_order = null;
  this.null_counts = null;
  this.repetition_level_histograms = null;
  this.definition_level_histograms = null;
  if (args) {
    if (args.null_pages !== undefined && args.null_pages !== null) {
      this.null_pages = Thrift.copyList(args.null_pages, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field null_pages is unset!');
    }
    if (args.min_values !== undefined && args.min_values !== null) {
      this.min_values = Thrift.copyList(args.min_values, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field min_values is unset!');
    }
    if (args.max_values !== undefined && args.max_values !== null) {
      this.max_values = Thrift.copyList(args.max_values, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field max_values is unset!');
    }
    if (args.boundary_order !== undefined && args.boundary_order !== null) {
      this.boundary_order = args.boundary_order;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field boundary_order is unset!');
    }
    if (args.null_counts !== undefined && args.null_counts !== null) {
      this.null_counts = Thrift.copyList(args.null_counts, [null]);
    }
    if (args.repetition_level_histograms !== undefined && args.repetition_level_histograms !== null) {
      this.repetition_level_histograms = Thrift.copyList(args.repetition_level_histograms, [null]);
    }
    if (args.definition_level_histograms !== undefined && args.definition_level_histograms !== null) {
      this.definition_level_histograms = Thrift.copyList(args.definition_level_histograms, [null]);
    }
  }
};
ColumnIndex.prototype = {};
ColumnIndex.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.null_pages = [];
        var _rtmp361 = input.readListBegin();
        var _size60 = _rtmp361.size || 0;
        for (var _i62 = 0; _i62 < _size60; ++_i62) {
          var elem63 = null;
          elem63 = input.readBool();
          this.null_pages.push(elem63);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.min_values = [];
        var _rtmp365 = input.readListBegin();
        var _size64 = _rtmp365.size || 0;
        for (var _i66 = 0; _i66 < _size64; ++_i66) {
          var elem67 = null;
          elem67 = input.readBinary();
          this.min_values.push(elem67);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        this.max_values = [];
        var _rtmp369 = input.readListBegin();
        var _size68 = _rtmp369.size || 0;
        for (var _i70 = 0; _i70 < _size68; ++_i70) {
          var elem71 = null;
          elem71 = input.readBinary();
          this.max_values.push(elem71);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.boundary_order = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.LIST) {
        this.null_counts = [];
        var _rtmp373 = input.readListBegin();
        var _size72 = _rtmp373.size || 0;
        for (var _i74 = 0; _i74 < _size72; ++_i74) {
          var elem75 = null;
          elem75 = input.readI64();
          this.null_counts.push(elem75);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.LIST) {
        this.repetition_level_histograms = [];
        var _rtmp377 = input.readListBegin();
        var _size76 = _rtmp377.size || 0;
        for (var _i78 = 0; _i78 < _size76; ++_i78) {
          var elem79 = null;
          elem79 = input.readI64();
          this.repetition_level_histograms.push(elem79);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.LIST) {
        this.definition_level_histograms = [];
        var _rtmp381 = input.readListBegin();
        var _size80 = _rtmp381.size || 0;
        for (var _i82 = 0; _i82 < _size80; ++_i82) {
          var elem83 = null;
          elem83 = input.readI64();
          this.definition_level_histograms.push(elem83);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ColumnIndex.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('ColumnIndex');
  if (this.null_pages !== null && this.null_pages !== undefined) {
    output.writeFieldBegin('null_pages', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.BOOL, this.null_pages.length);
    for (var iter84 in this.null_pages) {
      if (this.null_pages.hasOwnProperty(iter84)) {
        iter84 = this.null_pages[iter84];
        output.writeBool(iter84);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.min_values !== null && this.min_values !== undefined) {
    output.writeFieldBegin('min_values', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.min_values.length);
    for (var iter85 in this.min_values) {
      if (this.min_values.hasOwnProperty(iter85)) {
        iter85 = this.min_values[iter85];
        output.writeBinary(iter85);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.max_values !== null && this.max_values !== undefined) {
    output.writeFieldBegin('max_values', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRING, this.max_values.length);
    for (var iter86 in this.max_values) {
      if (this.max_values.hasOwnProperty(iter86)) {
        iter86 = this.max_values[iter86];
        output.writeBinary(iter86);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.boundary_order !== null && this.boundary_order !== undefined) {
    output.writeFieldBegin('boundary_order', Thrift.Type.I32, 4);
    output.writeI32(this.boundary_order);
    output.writeFieldEnd();
  }
  if (this.null_counts !== null && this.null_counts !== undefined) {
    output.writeFieldBegin('null_counts', Thrift.Type.LIST, 5);
    output.writeListBegin(Thrift.Type.I64, this.null_counts.length);
    for (var iter87 in this.null_counts) {
      if (this.null_counts.hasOwnProperty(iter87)) {
        iter87 = this.null_counts[iter87];
        output.writeI64(iter87);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.repetition_level_histograms !== null && this.repetition_level_histograms !== undefined) {
    output.writeFieldBegin('repetition_level_histograms', Thrift.Type.LIST, 6);
    output.writeListBegin(Thrift.Type.I64, this.repetition_level_histograms.length);
    for (var iter88 in this.repetition_level_histograms) {
      if (this.repetition_level_histograms.hasOwnProperty(iter88)) {
        iter88 = this.repetition_level_histograms[iter88];
        output.writeI64(iter88);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.definition_level_histograms !== null && this.definition_level_histograms !== undefined) {
    output.writeFieldBegin('definition_level_histograms', Thrift.Type.LIST, 7);
    output.writeListBegin(Thrift.Type.I64, this.definition_level_histograms.length);
    for (var iter89 in this.definition_level_histograms) {
      if (this.definition_level_histograms.hasOwnProperty(iter89)) {
        iter89 = this.definition_level_histograms[iter89];
        output.writeI64(iter89);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var AesGcmV1 = module.exports.AesGcmV1 = function(args) {
  this.aad_prefix = null;
  this.aad_file_unique = null;
  this.supply_aad_prefix = null;
  if (args) {
    if (args.aad_prefix !== undefined && args.aad_prefix !== null) {
      this.aad_prefix = args.aad_prefix;
    }
    if (args.aad_file_unique !== undefined && args.aad_file_unique !== null) {
      this.aad_file_unique = args.aad_file_unique;
    }
    if (args.supply_aad_prefix !== undefined && args.supply_aad_prefix !== null) {
      this.supply_aad_prefix = args.supply_aad_prefix;
    }
  }
};
AesGcmV1.prototype = {};
AesGcmV1.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.aad_prefix = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.aad_file_unique = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.supply_aad_prefix = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

AesGcmV1.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('AesGcmV1');
  if (this.aad_prefix !== null && this.aad_prefix !== undefined) {
    output.writeFieldBegin('aad_prefix', Thrift.Type.STRING, 1);
    output.writeBinary(this.aad_prefix);
    output.writeFieldEnd();
  }
  if (this.aad_file_unique !== null && this.aad_file_unique !== undefined) {
    output.writeFieldBegin('aad_file_unique', Thrift.Type.STRING, 2);
    output.writeBinary(this.aad_file_unique);
    output.writeFieldEnd();
  }
  if (this.supply_aad_prefix !== null && this.supply_aad_prefix !== undefined) {
    output.writeFieldBegin('supply_aad_prefix', Thrift.Type.BOOL, 3);
    output.writeBool(this.supply_aad_prefix);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var AesGcmCtrV1 = module.exports.AesGcmCtrV1 = function(args) {
  this.aad_prefix = null;
  this.aad_file_unique = null;
  this.supply_aad_prefix = null;
  if (args) {
    if (args.aad_prefix !== undefined && args.aad_prefix !== null) {
      this.aad_prefix = args.aad_prefix;
    }
    if (args.aad_file_unique !== undefined && args.aad_file_unique !== null) {
      this.aad_file_unique = args.aad_file_unique;
    }
    if (args.supply_aad_prefix !== undefined && args.supply_aad_prefix !== null) {
      this.supply_aad_prefix = args.supply_aad_prefix;
    }
  }
};
AesGcmCtrV1.prototype = {};
AesGcmCtrV1.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.aad_prefix = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.aad_file_unique = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.supply_aad_prefix = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

AesGcmCtrV1.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('AesGcmCtrV1');
  if (this.aad_prefix !== null && this.aad_prefix !== undefined) {
    output.writeFieldBegin('aad_prefix', Thrift.Type.STRING, 1);
    output.writeBinary(this.aad_prefix);
    output.writeFieldEnd();
  }
  if (this.aad_file_unique !== null && this.aad_file_unique !== undefined) {
    output.writeFieldBegin('aad_file_unique', Thrift.Type.STRING, 2);
    output.writeBinary(this.aad_file_unique);
    output.writeFieldEnd();
  }
  if (this.supply_aad_prefix !== null && this.supply_aad_prefix !== undefined) {
    output.writeFieldBegin('supply_aad_prefix', Thrift.Type.BOOL, 3);
    output.writeBool(this.supply_aad_prefix);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var EncryptionAlgorithm = module.exports.EncryptionAlgorithm = function(args) {
  this.AES_GCM_V1 = null;
  this.AES_GCM_CTR_V1 = null;
  if (args) {
    if (args.AES_GCM_V1 !== undefined && args.AES_GCM_V1 !== null) {
      this.AES_GCM_V1 = new ttypes.AesGcmV1(args.AES_GCM_V1);
    }
    if (args.AES_GCM_CTR_V1 !== undefined && args.AES_GCM_CTR_V1 !== null) {
      this.AES_GCM_CTR_V1 = new ttypes.AesGcmCtrV1(args.AES_GCM_CTR_V1);
    }
  }
};
EncryptionAlgorithm.prototype = {};
EncryptionAlgorithm.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.AES_GCM_V1 = new ttypes.AesGcmV1();
        this.AES_GCM_V1[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.AES_GCM_CTR_V1 = new ttypes.AesGcmCtrV1();
        this.AES_GCM_CTR_V1[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

EncryptionAlgorithm.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('EncryptionAlgorithm');
  if (this.AES_GCM_V1 !== null && this.AES_GCM_V1 !== undefined) {
    output.writeFieldBegin('AES_GCM_V1', Thrift.Type.STRUCT, 1);
    this.AES_GCM_V1[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.AES_GCM_CTR_V1 !== null && this.AES_GCM_CTR_V1 !== undefined) {
    output.writeFieldBegin('AES_GCM_CTR_V1', Thrift.Type.STRUCT, 2);
    this.AES_GCM_CTR_V1[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var FileMetaData = module.exports.FileMetaData = function(args) {
  this.version = null;
  this.schema = null;
  this.num_rows = null;
  this.row_groups = null;
  this.key_value_metadata = null;
  this.created_by = null;
  this.column_orders = null;
  this.encryption_algorithm = null;
  this.footer_signing_key_metadata = null;
  if (args) {
    if (args.version !== undefined && args.version !== null) {
      this.version = args.version;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field version is unset!');
    }
    if (args.schema !== undefined && args.schema !== null) {
      this.schema = Thrift.copyList(args.schema, [ttypes.SchemaElement]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field schema is unset!');
    }
    if (args.num_rows !== undefined && args.num_rows !== null) {
      this.num_rows = args.num_rows;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_rows is unset!');
    }
    if (args.row_groups !== undefined && args.row_groups !== null) {
      this.row_groups = Thrift.copyList(args.row_groups, [ttypes.RowGroup]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field row_groups is unset!');
    }
    if (args.key_value_metadata !== undefined && args.key_value_metadata !== null) {
      this.key_value_metadata = Thrift.copyList(args.key_value_metadata, [ttypes.KeyValue]);
    }
    if (args.created_by !== undefined && args.created_by !== null) {
      this.created_by = args.created_by;
    }
    if (args.column_orders !== undefined && args.column_orders !== null) {
      this.column_orders = Thrift.copyList(args.column_orders, [ttypes.ColumnOrder]);
    }
    if (args.encryption_algorithm !== undefined && args.encryption_algorithm !== null) {
      this.encryption_algorithm = new ttypes.EncryptionAlgorithm(args.encryption_algorithm);
    }
    if (args.footer_signing_key_metadata !== undefined && args.footer_signing_key_metadata !== null) {
      this.footer_signing_key_metadata = args.footer_signing_key_metadata;
    }
  }
};
FileMetaData.prototype = {};
FileMetaData.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.version = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.schema = [];
        var _rtmp391 = input.readListBegin();
        var _size90 = _rtmp391.size || 0;
        for (var _i92 = 0; _i92 < _size90; ++_i92) {
          var elem93 = null;
          elem93 = new ttypes.SchemaElement();
          elem93[Symbol.for("read")](input);
          this.schema.push(elem93);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.num_rows = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        this.row_groups = [];
        var _rtmp395 = input.readListBegin();
        var _size94 = _rtmp395.size || 0;
        for (var _i96 = 0; _i96 < _size94; ++_i96) {
          var elem97 = null;
          elem97 = new ttypes.RowGroup();
          elem97[Symbol.for("read")](input);
          this.row_groups.push(elem97);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.LIST) {
        this.key_value_metadata = [];
        var _rtmp399 = input.readListBegin();
        var _size98 = _rtmp399.size || 0;
        for (var _i100 = 0; _i100 < _size98; ++_i100) {
          var elem101 = null;
          elem101 = new ttypes.KeyValue();
          elem101[Symbol.for("read")](input);
          this.key_value_metadata.push(elem101);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.created_by = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.LIST) {
        this.column_orders = [];
        var _rtmp3103 = input.readListBegin();
        var _size102 = _rtmp3103.size || 0;
        for (var _i104 = 0; _i104 < _size102; ++_i104) {
          var elem105 = null;
          elem105 = new ttypes.ColumnOrder();
          elem105[Symbol.for("read")](input);
          this.column_orders.push(elem105);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.encryption_algorithm = new ttypes.EncryptionAlgorithm();
        this.encryption_algorithm[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.STRING) {
        this.footer_signing_key_metadata = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

FileMetaData.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('FileMetaData');
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.I32, 1);
    output.writeI32(this.version);
    output.writeFieldEnd();
  }
  if (this.schema !== null && this.schema !== undefined) {
    output.writeFieldBegin('schema', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.schema.length);
    for (var iter106 in this.schema) {
      if (this.schema.hasOwnProperty(iter106)) {
        iter106 = this.schema[iter106];
        iter106[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.num_rows !== null && this.num_rows !== undefined) {
    output.writeFieldBegin('num_rows', Thrift.Type.I64, 3);
    output.writeI64(this.num_rows);
    output.writeFieldEnd();
  }
  if (this.row_groups !== null && this.row_groups !== undefined) {
    output.writeFieldBegin('row_groups', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.STRUCT, this.row_groups.length);
    for (var iter107 in this.row_groups) {
      if (this.row_groups.hasOwnProperty(iter107)) {
        iter107 = this.row_groups[iter107];
        iter107[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.key_value_metadata !== null && this.key_value_metadata !== undefined) {
    output.writeFieldBegin('key_value_metadata', Thrift.Type.LIST, 5);
    output.writeListBegin(Thrift.Type.STRUCT, this.key_value_metadata.length);
    for (var iter108 in this.key_value_metadata) {
      if (this.key_value_metadata.hasOwnProperty(iter108)) {
        iter108 = this.key_value_metadata[iter108];
        iter108[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.created_by !== null && this.created_by !== undefined) {
    output.writeFieldBegin('created_by', Thrift.Type.STRING, 6);
    output.writeString(this.created_by);
    output.writeFieldEnd();
  }
  if (this.column_orders !== null && this.column_orders !== undefined) {
    output.writeFieldBegin('column_orders', Thrift.Type.LIST, 7);
    output.writeListBegin(Thrift.Type.STRUCT, this.column_orders.length);
    for (var iter109 in this.column_orders) {
      if (this.column_orders.hasOwnProperty(iter109)) {
        iter109 = this.column_orders[iter109];
        iter109[Symbol.for("write")](output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.encryption_algorithm !== null && this.encryption_algorithm !== undefined) {
    output.writeFieldBegin('encryption_algorithm', Thrift.Type.STRUCT, 8);
    this.encryption_algorithm[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.footer_signing_key_metadata !== null && this.footer_signing_key_metadata !== undefined) {
    output.writeFieldBegin('footer_signing_key_metadata', Thrift.Type.STRING, 9);
    output.writeBinary(this.footer_signing_key_metadata);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var FileCryptoMetaData = module.exports.FileCryptoMetaData = function(args) {
  this.encryption_algorithm = null;
  this.key_metadata = null;
  if (args) {
    if (args.encryption_algorithm !== undefined && args.encryption_algorithm !== null) {
      this.encryption_algorithm = new ttypes.EncryptionAlgorithm(args.encryption_algorithm);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encryption_algorithm is unset!');
    }
    if (args.key_metadata !== undefined && args.key_metadata !== null) {
      this.key_metadata = args.key_metadata;
    }
  }
};
FileCryptoMetaData.prototype = {};
FileCryptoMetaData.prototype[Symbol.for("read")] = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.encryption_algorithm = new ttypes.EncryptionAlgorithm();
        this.encryption_algorithm[Symbol.for("read")](input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.key_metadata = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

FileCryptoMetaData.prototype[Symbol.for("write")] = function(output) {
  output.writeStructBegin('FileCryptoMetaData');
  if (this.encryption_algorithm !== null && this.encryption_algorithm !== undefined) {
    output.writeFieldBegin('encryption_algorithm', Thrift.Type.STRUCT, 1);
    this.encryption_algorithm[Symbol.for("write")](output);
    output.writeFieldEnd();
  }
  if (this.key_metadata !== null && this.key_metadata !== undefined) {
    output.writeFieldBegin('key_metadata', Thrift.Type.STRING, 2);
    output.writeBinary(this.key_metadata);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

