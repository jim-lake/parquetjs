//
// Autogenerated by Thrift Compiler (0.22.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
"use strict";
var thrift = require('thrift');
var Thrift = thrift.Thrift;
var Q = thrift.Q;
var Int64 = require('node-int64');
var ttypes = module.exports = {};
ttypes.Type = {
    'BOOLEAN': 0,
    'INT32': 1,
    'INT64': 2,
    'INT96': 3,
    'FLOAT': 4,
    'DOUBLE': 5,
    'BYTE_ARRAY': 6,
    'FIXED_LEN_BYTE_ARRAY': 7
};
ttypes.ConvertedType = {
    'UTF8': 0,
    'MAP': 1,
    'MAP_KEY_VALUE': 2,
    'LIST': 3,
    'ENUM': 4,
    'DECIMAL': 5,
    'DATE': 6,
    'TIME_MILLIS': 7,
    'TIME_MICROS': 8,
    'TIMESTAMP_MILLIS': 9,
    'TIMESTAMP_MICROS': 10,
    'UINT_8': 11,
    'UINT_16': 12,
    'UINT_32': 13,
    'UINT_64': 14,
    'INT_8': 15,
    'INT_16': 16,
    'INT_32': 17,
    'INT_64': 18,
    'JSON': 19,
    'BSON': 20,
    'INTERVAL': 21
};
ttypes.FieldRepetitionType = {
    'REQUIRED': 0,
    'OPTIONAL': 1,
    'REPEATED': 2
};
ttypes.EdgeInterpolationAlgorithm = {
    'SPHERICAL': 0,
    'VINCENTY': 1,
    'THOMAS': 2,
    'ANDOYER': 3,
    'KARNEY': 4
};
ttypes.Encoding = {
    'PLAIN': 0,
    'PLAIN_DICTIONARY': 2,
    'RLE': 3,
    'BIT_PACKED': 4,
    'DELTA_BINARY_PACKED': 5,
    'DELTA_LENGTH_BYTE_ARRAY': 6,
    'DELTA_BYTE_ARRAY': 7,
    'RLE_DICTIONARY': 8,
    'BYTE_STREAM_SPLIT': 9
};
ttypes.CompressionCodec = {
    'UNCOMPRESSED': 0,
    'SNAPPY': 1,
    'GZIP': 2,
    'LZO': 3,
    'BROTLI': 4,
    'LZ4': 5,
    'ZSTD': 6,
    'LZ4_RAW': 7
};
ttypes.PageType = {
    'DATA_PAGE': 0,
    'INDEX_PAGE': 1,
    'DICTIONARY_PAGE': 2,
    'DATA_PAGE_V2': 3
};
ttypes.BoundaryOrder = {
    'UNORDERED': 0,
    'ASCENDING': 1,
    'DESCENDING': 2
};
var SizeStatistics = module.exports.SizeStatistics = function (args) {
    this.unencoded_byte_array_data_bytes = null;
    this.repetition_level_histogram = null;
    this.definition_level_histogram = null;
    if (args) {
        if (args.unencoded_byte_array_data_bytes !== undefined && args.unencoded_byte_array_data_bytes !== null) {
            this.unencoded_byte_array_data_bytes = args.unencoded_byte_array_data_bytes;
        }
        if (args.repetition_level_histogram !== undefined && args.repetition_level_histogram !== null) {
            this.repetition_level_histogram = Thrift.copyList(args.repetition_level_histogram, [null]);
        }
        if (args.definition_level_histogram !== undefined && args.definition_level_histogram !== null) {
            this.definition_level_histogram = Thrift.copyList(args.definition_level_histogram, [null]);
        }
    }
};
SizeStatistics.prototype = {};
SizeStatistics.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I64) {
                    this.unencoded_byte_array_data_bytes = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.LIST) {
                    this.repetition_level_histogram = [];
                    var _rtmp31 = input.readListBegin();
                    var _size0 = _rtmp31.size || 0;
                    for (var _i2 = 0; _i2 < _size0; ++_i2) {
                        var elem3 = null;
                        elem3 = input.readI64();
                        this.repetition_level_histogram.push(elem3);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.LIST) {
                    this.definition_level_histogram = [];
                    var _rtmp35 = input.readListBegin();
                    var _size4 = _rtmp35.size || 0;
                    for (var _i6 = 0; _i6 < _size4; ++_i6) {
                        var elem7 = null;
                        elem7 = input.readI64();
                        this.definition_level_histogram.push(elem7);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
SizeStatistics.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('SizeStatistics');
    if (this.unencoded_byte_array_data_bytes !== null && this.unencoded_byte_array_data_bytes !== undefined) {
        output.writeFieldBegin('unencoded_byte_array_data_bytes', Thrift.Type.I64, 1);
        output.writeI64(this.unencoded_byte_array_data_bytes);
        output.writeFieldEnd();
    }
    if (this.repetition_level_histogram !== null && this.repetition_level_histogram !== undefined) {
        output.writeFieldBegin('repetition_level_histogram', Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.I64, this.repetition_level_histogram.length);
        for (var iter8 in this.repetition_level_histogram) {
            if (this.repetition_level_histogram.hasOwnProperty(iter8)) {
                iter8 = this.repetition_level_histogram[iter8];
                output.writeI64(iter8);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.definition_level_histogram !== null && this.definition_level_histogram !== undefined) {
        output.writeFieldBegin('definition_level_histogram', Thrift.Type.LIST, 3);
        output.writeListBegin(Thrift.Type.I64, this.definition_level_histogram.length);
        for (var iter9 in this.definition_level_histogram) {
            if (this.definition_level_histogram.hasOwnProperty(iter9)) {
                iter9 = this.definition_level_histogram[iter9];
                output.writeI64(iter9);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var BoundingBox = module.exports.BoundingBox = function (args) {
    this.xmin = null;
    this.xmax = null;
    this.ymin = null;
    this.ymax = null;
    this.zmin = null;
    this.zmax = null;
    this.mmin = null;
    this.mmax = null;
    if (args) {
        if (args.xmin !== undefined && args.xmin !== null) {
            this.xmin = args.xmin;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field xmin is unset!');
        }
        if (args.xmax !== undefined && args.xmax !== null) {
            this.xmax = args.xmax;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field xmax is unset!');
        }
        if (args.ymin !== undefined && args.ymin !== null) {
            this.ymin = args.ymin;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ymin is unset!');
        }
        if (args.ymax !== undefined && args.ymax !== null) {
            this.ymax = args.ymax;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ymax is unset!');
        }
        if (args.zmin !== undefined && args.zmin !== null) {
            this.zmin = args.zmin;
        }
        if (args.zmax !== undefined && args.zmax !== null) {
            this.zmax = args.zmax;
        }
        if (args.mmin !== undefined && args.mmin !== null) {
            this.mmin = args.mmin;
        }
        if (args.mmax !== undefined && args.mmax !== null) {
            this.mmax = args.mmax;
        }
    }
};
BoundingBox.prototype = {};
BoundingBox.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.xmin = input.readDouble();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.xmax = input.readDouble();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.ymin = input.readDouble();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.ymax = input.readDouble();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.zmin = input.readDouble();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.zmax = input.readDouble();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.mmin = input.readDouble();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.mmax = input.readDouble();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
BoundingBox.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('BoundingBox');
    if (this.xmin !== null && this.xmin !== undefined) {
        output.writeFieldBegin('xmin', Thrift.Type.DOUBLE, 1);
        output.writeDouble(this.xmin);
        output.writeFieldEnd();
    }
    if (this.xmax !== null && this.xmax !== undefined) {
        output.writeFieldBegin('xmax', Thrift.Type.DOUBLE, 2);
        output.writeDouble(this.xmax);
        output.writeFieldEnd();
    }
    if (this.ymin !== null && this.ymin !== undefined) {
        output.writeFieldBegin('ymin', Thrift.Type.DOUBLE, 3);
        output.writeDouble(this.ymin);
        output.writeFieldEnd();
    }
    if (this.ymax !== null && this.ymax !== undefined) {
        output.writeFieldBegin('ymax', Thrift.Type.DOUBLE, 4);
        output.writeDouble(this.ymax);
        output.writeFieldEnd();
    }
    if (this.zmin !== null && this.zmin !== undefined) {
        output.writeFieldBegin('zmin', Thrift.Type.DOUBLE, 5);
        output.writeDouble(this.zmin);
        output.writeFieldEnd();
    }
    if (this.zmax !== null && this.zmax !== undefined) {
        output.writeFieldBegin('zmax', Thrift.Type.DOUBLE, 6);
        output.writeDouble(this.zmax);
        output.writeFieldEnd();
    }
    if (this.mmin !== null && this.mmin !== undefined) {
        output.writeFieldBegin('mmin', Thrift.Type.DOUBLE, 7);
        output.writeDouble(this.mmin);
        output.writeFieldEnd();
    }
    if (this.mmax !== null && this.mmax !== undefined) {
        output.writeFieldBegin('mmax', Thrift.Type.DOUBLE, 8);
        output.writeDouble(this.mmax);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var GeospatialStatistics = module.exports.GeospatialStatistics = function (args) {
    this.bbox = null;
    this.geospatial_types = null;
    if (args) {
        if (args.bbox !== undefined && args.bbox !== null) {
            this.bbox = new ttypes.BoundingBox(args.bbox);
        }
        if (args.geospatial_types !== undefined && args.geospatial_types !== null) {
            this.geospatial_types = Thrift.copyList(args.geospatial_types, [null]);
        }
    }
};
GeospatialStatistics.prototype = {};
GeospatialStatistics.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.bbox = new ttypes.BoundingBox();
                    this.bbox[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.LIST) {
                    this.geospatial_types = [];
                    var _rtmp311 = input.readListBegin();
                    var _size10 = _rtmp311.size || 0;
                    for (var _i12 = 0; _i12 < _size10; ++_i12) {
                        var elem13 = null;
                        elem13 = input.readI32();
                        this.geospatial_types.push(elem13);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
GeospatialStatistics.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('GeospatialStatistics');
    if (this.bbox !== null && this.bbox !== undefined) {
        output.writeFieldBegin('bbox', Thrift.Type.STRUCT, 1);
        this.bbox[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.geospatial_types !== null && this.geospatial_types !== undefined) {
        output.writeFieldBegin('geospatial_types', Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.I32, this.geospatial_types.length);
        for (var iter14 in this.geospatial_types) {
            if (this.geospatial_types.hasOwnProperty(iter14)) {
                iter14 = this.geospatial_types[iter14];
                output.writeI32(iter14);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var Statistics = module.exports.Statistics = function (args) {
    this.max = null;
    this.min = null;
    this.null_count = null;
    this.distinct_count = null;
    this.max_value = null;
    this.min_value = null;
    this.is_max_value_exact = null;
    this.is_min_value_exact = null;
    if (args) {
        if (args.max !== undefined && args.max !== null) {
            this.max = args.max;
        }
        if (args.min !== undefined && args.min !== null) {
            this.min = args.min;
        }
        if (args.null_count !== undefined && args.null_count !== null) {
            this.null_count = args.null_count;
        }
        if (args.distinct_count !== undefined && args.distinct_count !== null) {
            this.distinct_count = args.distinct_count;
        }
        if (args.max_value !== undefined && args.max_value !== null) {
            this.max_value = args.max_value;
        }
        if (args.min_value !== undefined && args.min_value !== null) {
            this.min_value = args.min_value;
        }
        if (args.is_max_value_exact !== undefined && args.is_max_value_exact !== null) {
            this.is_max_value_exact = args.is_max_value_exact;
        }
        if (args.is_min_value_exact !== undefined && args.is_min_value_exact !== null) {
            this.is_min_value_exact = args.is_min_value_exact;
        }
    }
};
Statistics.prototype = {};
Statistics.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.max = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.min = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I64) {
                    this.null_count = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I64) {
                    this.distinct_count = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRING) {
                    this.max_value = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.STRING) {
                    this.min_value = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.BOOL) {
                    this.is_max_value_exact = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.BOOL) {
                    this.is_min_value_exact = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
Statistics.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('Statistics');
    if (this.max !== null && this.max !== undefined) {
        output.writeFieldBegin('max', Thrift.Type.STRING, 1);
        output.writeBinary(this.max);
        output.writeFieldEnd();
    }
    if (this.min !== null && this.min !== undefined) {
        output.writeFieldBegin('min', Thrift.Type.STRING, 2);
        output.writeBinary(this.min);
        output.writeFieldEnd();
    }
    if (this.null_count !== null && this.null_count !== undefined) {
        output.writeFieldBegin('null_count', Thrift.Type.I64, 3);
        output.writeI64(this.null_count);
        output.writeFieldEnd();
    }
    if (this.distinct_count !== null && this.distinct_count !== undefined) {
        output.writeFieldBegin('distinct_count', Thrift.Type.I64, 4);
        output.writeI64(this.distinct_count);
        output.writeFieldEnd();
    }
    if (this.max_value !== null && this.max_value !== undefined) {
        output.writeFieldBegin('max_value', Thrift.Type.STRING, 5);
        output.writeBinary(this.max_value);
        output.writeFieldEnd();
    }
    if (this.min_value !== null && this.min_value !== undefined) {
        output.writeFieldBegin('min_value', Thrift.Type.STRING, 6);
        output.writeBinary(this.min_value);
        output.writeFieldEnd();
    }
    if (this.is_max_value_exact !== null && this.is_max_value_exact !== undefined) {
        output.writeFieldBegin('is_max_value_exact', Thrift.Type.BOOL, 7);
        output.writeBool(this.is_max_value_exact);
        output.writeFieldEnd();
    }
    if (this.is_min_value_exact !== null && this.is_min_value_exact !== undefined) {
        output.writeFieldBegin('is_min_value_exact', Thrift.Type.BOOL, 8);
        output.writeBool(this.is_min_value_exact);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var StringType = module.exports.StringType = function (args) {
};
StringType.prototype = {};
StringType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
StringType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('StringType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var UUIDType = module.exports.UUIDType = function (args) {
};
UUIDType.prototype = {};
UUIDType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
UUIDType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('UUIDType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var MapType = module.exports.MapType = function (args) {
};
MapType.prototype = {};
MapType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
MapType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('MapType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var ListType = module.exports.ListType = function (args) {
};
ListType.prototype = {};
ListType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
ListType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('ListType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var EnumType = module.exports.EnumType = function (args) {
};
EnumType.prototype = {};
EnumType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
EnumType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('EnumType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var DateType = module.exports.DateType = function (args) {
};
DateType.prototype = {};
DateType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
DateType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('DateType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var Float16Type = module.exports.Float16Type = function (args) {
};
Float16Type.prototype = {};
Float16Type.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
Float16Type.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('Float16Type');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var NullType = module.exports.NullType = function (args) {
};
NullType.prototype = {};
NullType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
NullType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('NullType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var DecimalType = module.exports.DecimalType = function (args) {
    this.scale = null;
    this.precision = null;
    if (args) {
        if (args.scale !== undefined && args.scale !== null) {
            this.scale = args.scale;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field scale is unset!');
        }
        if (args.precision !== undefined && args.precision !== null) {
            this.precision = args.precision;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field precision is unset!');
        }
    }
};
DecimalType.prototype = {};
DecimalType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.scale = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.precision = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
DecimalType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('DecimalType');
    if (this.scale !== null && this.scale !== undefined) {
        output.writeFieldBegin('scale', Thrift.Type.I32, 1);
        output.writeI32(this.scale);
        output.writeFieldEnd();
    }
    if (this.precision !== null && this.precision !== undefined) {
        output.writeFieldBegin('precision', Thrift.Type.I32, 2);
        output.writeI32(this.precision);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var MilliSeconds = module.exports.MilliSeconds = function (args) {
};
MilliSeconds.prototype = {};
MilliSeconds.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
MilliSeconds.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('MilliSeconds');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var MicroSeconds = module.exports.MicroSeconds = function (args) {
};
MicroSeconds.prototype = {};
MicroSeconds.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
MicroSeconds.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('MicroSeconds');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var NanoSeconds = module.exports.NanoSeconds = function (args) {
};
NanoSeconds.prototype = {};
NanoSeconds.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
NanoSeconds.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('NanoSeconds');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var TimeUnit = module.exports.TimeUnit = function (args) {
    this.MILLIS = null;
    this.MICROS = null;
    this.NANOS = null;
    if (args) {
        if (args.MILLIS !== undefined && args.MILLIS !== null) {
            this.MILLIS = new ttypes.MilliSeconds(args.MILLIS);
        }
        if (args.MICROS !== undefined && args.MICROS !== null) {
            this.MICROS = new ttypes.MicroSeconds(args.MICROS);
        }
        if (args.NANOS !== undefined && args.NANOS !== null) {
            this.NANOS = new ttypes.NanoSeconds(args.NANOS);
        }
    }
};
TimeUnit.prototype = {};
TimeUnit.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.MILLIS = new ttypes.MilliSeconds();
                    this.MILLIS[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.MICROS = new ttypes.MicroSeconds();
                    this.MICROS[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.NANOS = new ttypes.NanoSeconds();
                    this.NANOS[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
TimeUnit.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('TimeUnit');
    if (this.MILLIS !== null && this.MILLIS !== undefined) {
        output.writeFieldBegin('MILLIS', Thrift.Type.STRUCT, 1);
        this.MILLIS[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.MICROS !== null && this.MICROS !== undefined) {
        output.writeFieldBegin('MICROS', Thrift.Type.STRUCT, 2);
        this.MICROS[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.NANOS !== null && this.NANOS !== undefined) {
        output.writeFieldBegin('NANOS', Thrift.Type.STRUCT, 3);
        this.NANOS[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var TimestampType = module.exports.TimestampType = function (args) {
    this.isAdjustedToUTC = null;
    this.unit = null;
    if (args) {
        if (args.isAdjustedToUTC !== undefined && args.isAdjustedToUTC !== null) {
            this.isAdjustedToUTC = args.isAdjustedToUTC;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field isAdjustedToUTC is unset!');
        }
        if (args.unit !== undefined && args.unit !== null) {
            this.unit = new ttypes.TimeUnit(args.unit);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field unit is unset!');
        }
    }
};
TimestampType.prototype = {};
TimestampType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.BOOL) {
                    this.isAdjustedToUTC = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.unit = new ttypes.TimeUnit();
                    this.unit[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
TimestampType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('TimestampType');
    if (this.isAdjustedToUTC !== null && this.isAdjustedToUTC !== undefined) {
        output.writeFieldBegin('isAdjustedToUTC', Thrift.Type.BOOL, 1);
        output.writeBool(this.isAdjustedToUTC);
        output.writeFieldEnd();
    }
    if (this.unit !== null && this.unit !== undefined) {
        output.writeFieldBegin('unit', Thrift.Type.STRUCT, 2);
        this.unit[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var TimeType = module.exports.TimeType = function (args) {
    this.isAdjustedToUTC = null;
    this.unit = null;
    if (args) {
        if (args.isAdjustedToUTC !== undefined && args.isAdjustedToUTC !== null) {
            this.isAdjustedToUTC = args.isAdjustedToUTC;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field isAdjustedToUTC is unset!');
        }
        if (args.unit !== undefined && args.unit !== null) {
            this.unit = new ttypes.TimeUnit(args.unit);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field unit is unset!');
        }
    }
};
TimeType.prototype = {};
TimeType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.BOOL) {
                    this.isAdjustedToUTC = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.unit = new ttypes.TimeUnit();
                    this.unit[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
TimeType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('TimeType');
    if (this.isAdjustedToUTC !== null && this.isAdjustedToUTC !== undefined) {
        output.writeFieldBegin('isAdjustedToUTC', Thrift.Type.BOOL, 1);
        output.writeBool(this.isAdjustedToUTC);
        output.writeFieldEnd();
    }
    if (this.unit !== null && this.unit !== undefined) {
        output.writeFieldBegin('unit', Thrift.Type.STRUCT, 2);
        this.unit[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var IntType = module.exports.IntType = function (args) {
    this.bitWidth = null;
    this.isSigned = null;
    if (args) {
        if (args.bitWidth !== undefined && args.bitWidth !== null) {
            this.bitWidth = args.bitWidth;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field bitWidth is unset!');
        }
        if (args.isSigned !== undefined && args.isSigned !== null) {
            this.isSigned = args.isSigned;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field isSigned is unset!');
        }
    }
};
IntType.prototype = {};
IntType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.BYTE) {
                    this.bitWidth = input.readByte();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.BOOL) {
                    this.isSigned = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
IntType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('IntType');
    if (this.bitWidth !== null && this.bitWidth !== undefined) {
        output.writeFieldBegin('bitWidth', Thrift.Type.BYTE, 1);
        output.writeByte(this.bitWidth);
        output.writeFieldEnd();
    }
    if (this.isSigned !== null && this.isSigned !== undefined) {
        output.writeFieldBegin('isSigned', Thrift.Type.BOOL, 2);
        output.writeBool(this.isSigned);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var JsonType = module.exports.JsonType = function (args) {
};
JsonType.prototype = {};
JsonType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
JsonType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('JsonType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var BsonType = module.exports.BsonType = function (args) {
};
BsonType.prototype = {};
BsonType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
BsonType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('BsonType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var VariantType = module.exports.VariantType = function (args) {
    this.specification_version = null;
    if (args) {
        if (args.specification_version !== undefined && args.specification_version !== null) {
            this.specification_version = args.specification_version;
        }
    }
};
VariantType.prototype = {};
VariantType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.BYTE) {
                    this.specification_version = input.readByte();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
VariantType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('VariantType');
    if (this.specification_version !== null && this.specification_version !== undefined) {
        output.writeFieldBegin('specification_version', Thrift.Type.BYTE, 1);
        output.writeByte(this.specification_version);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var GeometryType = module.exports.GeometryType = function (args) {
    this.crs = null;
    if (args) {
        if (args.crs !== undefined && args.crs !== null) {
            this.crs = args.crs;
        }
    }
};
GeometryType.prototype = {};
GeometryType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.crs = input.readString();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
GeometryType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('GeometryType');
    if (this.crs !== null && this.crs !== undefined) {
        output.writeFieldBegin('crs', Thrift.Type.STRING, 1);
        output.writeString(this.crs);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var GeographyType = module.exports.GeographyType = function (args) {
    this.crs = null;
    this.algorithm = null;
    if (args) {
        if (args.crs !== undefined && args.crs !== null) {
            this.crs = args.crs;
        }
        if (args.algorithm !== undefined && args.algorithm !== null) {
            this.algorithm = args.algorithm;
        }
    }
};
GeographyType.prototype = {};
GeographyType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.crs = input.readString();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.algorithm = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
GeographyType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('GeographyType');
    if (this.crs !== null && this.crs !== undefined) {
        output.writeFieldBegin('crs', Thrift.Type.STRING, 1);
        output.writeString(this.crs);
        output.writeFieldEnd();
    }
    if (this.algorithm !== null && this.algorithm !== undefined) {
        output.writeFieldBegin('algorithm', Thrift.Type.I32, 2);
        output.writeI32(this.algorithm);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var LogicalType = module.exports.LogicalType = function (args) {
    this.STRING = null;
    this.MAP = null;
    this.LIST = null;
    this.ENUM = null;
    this.DECIMAL = null;
    this.DATE = null;
    this.TIME = null;
    this.TIMESTAMP = null;
    this.INTEGER = null;
    this.UNKNOWN = null;
    this.JSON = null;
    this.BSON = null;
    this.UUID = null;
    this.FLOAT16 = null;
    this.VARIANT = null;
    this.GEOMETRY = null;
    this.GEOGRAPHY = null;
    if (args) {
        if (args.STRING !== undefined && args.STRING !== null) {
            this.STRING = new ttypes.StringType(args.STRING);
        }
        if (args.MAP !== undefined && args.MAP !== null) {
            this.MAP = new ttypes.MapType(args.MAP);
        }
        if (args.LIST !== undefined && args.LIST !== null) {
            this.LIST = new ttypes.ListType(args.LIST);
        }
        if (args.ENUM !== undefined && args.ENUM !== null) {
            this.ENUM = new ttypes.EnumType(args.ENUM);
        }
        if (args.DECIMAL !== undefined && args.DECIMAL !== null) {
            this.DECIMAL = new ttypes.DecimalType(args.DECIMAL);
        }
        if (args.DATE !== undefined && args.DATE !== null) {
            this.DATE = new ttypes.DateType(args.DATE);
        }
        if (args.TIME !== undefined && args.TIME !== null) {
            this.TIME = new ttypes.TimeType(args.TIME);
        }
        if (args.TIMESTAMP !== undefined && args.TIMESTAMP !== null) {
            this.TIMESTAMP = new ttypes.TimestampType(args.TIMESTAMP);
        }
        if (args.INTEGER !== undefined && args.INTEGER !== null) {
            this.INTEGER = new ttypes.IntType(args.INTEGER);
        }
        if (args.UNKNOWN !== undefined && args.UNKNOWN !== null) {
            this.UNKNOWN = new ttypes.NullType(args.UNKNOWN);
        }
        if (args.JSON !== undefined && args.JSON !== null) {
            this.JSON = new ttypes.JsonType(args.JSON);
        }
        if (args.BSON !== undefined && args.BSON !== null) {
            this.BSON = new ttypes.BsonType(args.BSON);
        }
        if (args.UUID !== undefined && args.UUID !== null) {
            this.UUID = new ttypes.UUIDType(args.UUID);
        }
        if (args.FLOAT16 !== undefined && args.FLOAT16 !== null) {
            this.FLOAT16 = new ttypes.Float16Type(args.FLOAT16);
        }
        if (args.VARIANT !== undefined && args.VARIANT !== null) {
            this.VARIANT = new ttypes.VariantType(args.VARIANT);
        }
        if (args.GEOMETRY !== undefined && args.GEOMETRY !== null) {
            this.GEOMETRY = new ttypes.GeometryType(args.GEOMETRY);
        }
        if (args.GEOGRAPHY !== undefined && args.GEOGRAPHY !== null) {
            this.GEOGRAPHY = new ttypes.GeographyType(args.GEOGRAPHY);
        }
    }
};
LogicalType.prototype = {};
LogicalType.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.STRING = new ttypes.StringType();
                    this.STRING[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.MAP = new ttypes.MapType();
                    this.MAP[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.LIST = new ttypes.ListType();
                    this.LIST[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRUCT) {
                    this.ENUM = new ttypes.EnumType();
                    this.ENUM[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRUCT) {
                    this.DECIMAL = new ttypes.DecimalType();
                    this.DECIMAL[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.STRUCT) {
                    this.DATE = new ttypes.DateType();
                    this.DATE[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.STRUCT) {
                    this.TIME = new ttypes.TimeType();
                    this.TIME[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.STRUCT) {
                    this.TIMESTAMP = new ttypes.TimestampType();
                    this.TIMESTAMP[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 10:
                if (ftype == Thrift.Type.STRUCT) {
                    this.INTEGER = new ttypes.IntType();
                    this.INTEGER[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 11:
                if (ftype == Thrift.Type.STRUCT) {
                    this.UNKNOWN = new ttypes.NullType();
                    this.UNKNOWN[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 12:
                if (ftype == Thrift.Type.STRUCT) {
                    this.JSON = new ttypes.JsonType();
                    this.JSON[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 13:
                if (ftype == Thrift.Type.STRUCT) {
                    this.BSON = new ttypes.BsonType();
                    this.BSON[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 14:
                if (ftype == Thrift.Type.STRUCT) {
                    this.UUID = new ttypes.UUIDType();
                    this.UUID[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 15:
                if (ftype == Thrift.Type.STRUCT) {
                    this.FLOAT16 = new ttypes.Float16Type();
                    this.FLOAT16[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 16:
                if (ftype == Thrift.Type.STRUCT) {
                    this.VARIANT = new ttypes.VariantType();
                    this.VARIANT[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 17:
                if (ftype == Thrift.Type.STRUCT) {
                    this.GEOMETRY = new ttypes.GeometryType();
                    this.GEOMETRY[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 18:
                if (ftype == Thrift.Type.STRUCT) {
                    this.GEOGRAPHY = new ttypes.GeographyType();
                    this.GEOGRAPHY[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
LogicalType.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('LogicalType');
    if (this.STRING !== null && this.STRING !== undefined) {
        output.writeFieldBegin('STRING', Thrift.Type.STRUCT, 1);
        this.STRING[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.MAP !== null && this.MAP !== undefined) {
        output.writeFieldBegin('MAP', Thrift.Type.STRUCT, 2);
        this.MAP[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.LIST !== null && this.LIST !== undefined) {
        output.writeFieldBegin('LIST', Thrift.Type.STRUCT, 3);
        this.LIST[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.ENUM !== null && this.ENUM !== undefined) {
        output.writeFieldBegin('ENUM', Thrift.Type.STRUCT, 4);
        this.ENUM[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.DECIMAL !== null && this.DECIMAL !== undefined) {
        output.writeFieldBegin('DECIMAL', Thrift.Type.STRUCT, 5);
        this.DECIMAL[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.DATE !== null && this.DATE !== undefined) {
        output.writeFieldBegin('DATE', Thrift.Type.STRUCT, 6);
        this.DATE[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.TIME !== null && this.TIME !== undefined) {
        output.writeFieldBegin('TIME', Thrift.Type.STRUCT, 7);
        this.TIME[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.TIMESTAMP !== null && this.TIMESTAMP !== undefined) {
        output.writeFieldBegin('TIMESTAMP', Thrift.Type.STRUCT, 8);
        this.TIMESTAMP[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.INTEGER !== null && this.INTEGER !== undefined) {
        output.writeFieldBegin('INTEGER', Thrift.Type.STRUCT, 10);
        this.INTEGER[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.UNKNOWN !== null && this.UNKNOWN !== undefined) {
        output.writeFieldBegin('UNKNOWN', Thrift.Type.STRUCT, 11);
        this.UNKNOWN[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.JSON !== null && this.JSON !== undefined) {
        output.writeFieldBegin('JSON', Thrift.Type.STRUCT, 12);
        this.JSON[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.BSON !== null && this.BSON !== undefined) {
        output.writeFieldBegin('BSON', Thrift.Type.STRUCT, 13);
        this.BSON[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.UUID !== null && this.UUID !== undefined) {
        output.writeFieldBegin('UUID', Thrift.Type.STRUCT, 14);
        this.UUID[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.FLOAT16 !== null && this.FLOAT16 !== undefined) {
        output.writeFieldBegin('FLOAT16', Thrift.Type.STRUCT, 15);
        this.FLOAT16[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.VARIANT !== null && this.VARIANT !== undefined) {
        output.writeFieldBegin('VARIANT', Thrift.Type.STRUCT, 16);
        this.VARIANT[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.GEOMETRY !== null && this.GEOMETRY !== undefined) {
        output.writeFieldBegin('GEOMETRY', Thrift.Type.STRUCT, 17);
        this.GEOMETRY[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.GEOGRAPHY !== null && this.GEOGRAPHY !== undefined) {
        output.writeFieldBegin('GEOGRAPHY', Thrift.Type.STRUCT, 18);
        this.GEOGRAPHY[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var SchemaElement = module.exports.SchemaElement = function (args) {
    this.type = null;
    this.type_length = null;
    this.repetition_type = null;
    this.name = null;
    this.num_children = null;
    this.converted_type = null;
    this.scale = null;
    this.precision = null;
    this.field_id = null;
    this.logicalType = null;
    if (args) {
        if (args.type !== undefined && args.type !== null) {
            this.type = args.type;
        }
        if (args.type_length !== undefined && args.type_length !== null) {
            this.type_length = args.type_length;
        }
        if (args.repetition_type !== undefined && args.repetition_type !== null) {
            this.repetition_type = args.repetition_type;
        }
        if (args.name !== undefined && args.name !== null) {
            this.name = args.name;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field name is unset!');
        }
        if (args.num_children !== undefined && args.num_children !== null) {
            this.num_children = args.num_children;
        }
        if (args.converted_type !== undefined && args.converted_type !== null) {
            this.converted_type = args.converted_type;
        }
        if (args.scale !== undefined && args.scale !== null) {
            this.scale = args.scale;
        }
        if (args.precision !== undefined && args.precision !== null) {
            this.precision = args.precision;
        }
        if (args.field_id !== undefined && args.field_id !== null) {
            this.field_id = args.field_id;
        }
        if (args.logicalType !== undefined && args.logicalType !== null) {
            this.logicalType = new ttypes.LogicalType(args.logicalType);
        }
    }
};
SchemaElement.prototype = {};
SchemaElement.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.type = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.type_length = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.repetition_type = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRING) {
                    this.name = input.readString();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I32) {
                    this.num_children = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I32) {
                    this.converted_type = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I32) {
                    this.scale = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.I32) {
                    this.precision = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.I32) {
                    this.field_id = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 10:
                if (ftype == Thrift.Type.STRUCT) {
                    this.logicalType = new ttypes.LogicalType();
                    this.logicalType[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
SchemaElement.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('SchemaElement');
    if (this.type !== null && this.type !== undefined) {
        output.writeFieldBegin('type', Thrift.Type.I32, 1);
        output.writeI32(this.type);
        output.writeFieldEnd();
    }
    if (this.type_length !== null && this.type_length !== undefined) {
        output.writeFieldBegin('type_length', Thrift.Type.I32, 2);
        output.writeI32(this.type_length);
        output.writeFieldEnd();
    }
    if (this.repetition_type !== null && this.repetition_type !== undefined) {
        output.writeFieldBegin('repetition_type', Thrift.Type.I32, 3);
        output.writeI32(this.repetition_type);
        output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
        output.writeFieldBegin('name', Thrift.Type.STRING, 4);
        output.writeString(this.name);
        output.writeFieldEnd();
    }
    if (this.num_children !== null && this.num_children !== undefined) {
        output.writeFieldBegin('num_children', Thrift.Type.I32, 5);
        output.writeI32(this.num_children);
        output.writeFieldEnd();
    }
    if (this.converted_type !== null && this.converted_type !== undefined) {
        output.writeFieldBegin('converted_type', Thrift.Type.I32, 6);
        output.writeI32(this.converted_type);
        output.writeFieldEnd();
    }
    if (this.scale !== null && this.scale !== undefined) {
        output.writeFieldBegin('scale', Thrift.Type.I32, 7);
        output.writeI32(this.scale);
        output.writeFieldEnd();
    }
    if (this.precision !== null && this.precision !== undefined) {
        output.writeFieldBegin('precision', Thrift.Type.I32, 8);
        output.writeI32(this.precision);
        output.writeFieldEnd();
    }
    if (this.field_id !== null && this.field_id !== undefined) {
        output.writeFieldBegin('field_id', Thrift.Type.I32, 9);
        output.writeI32(this.field_id);
        output.writeFieldEnd();
    }
    if (this.logicalType !== null && this.logicalType !== undefined) {
        output.writeFieldBegin('logicalType', Thrift.Type.STRUCT, 10);
        this.logicalType[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var DataPageHeader = module.exports.DataPageHeader = function (args) {
    this.num_values = null;
    this.encoding = null;
    this.definition_level_encoding = null;
    this.repetition_level_encoding = null;
    this.statistics = null;
    if (args) {
        if (args.num_values !== undefined && args.num_values !== null) {
            this.num_values = args.num_values;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_values is unset!');
        }
        if (args.encoding !== undefined && args.encoding !== null) {
            this.encoding = args.encoding;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encoding is unset!');
        }
        if (args.definition_level_encoding !== undefined && args.definition_level_encoding !== null) {
            this.definition_level_encoding = args.definition_level_encoding;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field definition_level_encoding is unset!');
        }
        if (args.repetition_level_encoding !== undefined && args.repetition_level_encoding !== null) {
            this.repetition_level_encoding = args.repetition_level_encoding;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field repetition_level_encoding is unset!');
        }
        if (args.statistics !== undefined && args.statistics !== null) {
            this.statistics = new ttypes.Statistics(args.statistics);
        }
    }
};
DataPageHeader.prototype = {};
DataPageHeader.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.num_values = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.encoding = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.definition_level_encoding = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.repetition_level_encoding = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRUCT) {
                    this.statistics = new ttypes.Statistics();
                    this.statistics[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
DataPageHeader.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('DataPageHeader');
    if (this.num_values !== null && this.num_values !== undefined) {
        output.writeFieldBegin('num_values', Thrift.Type.I32, 1);
        output.writeI32(this.num_values);
        output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
        output.writeFieldBegin('encoding', Thrift.Type.I32, 2);
        output.writeI32(this.encoding);
        output.writeFieldEnd();
    }
    if (this.definition_level_encoding !== null && this.definition_level_encoding !== undefined) {
        output.writeFieldBegin('definition_level_encoding', Thrift.Type.I32, 3);
        output.writeI32(this.definition_level_encoding);
        output.writeFieldEnd();
    }
    if (this.repetition_level_encoding !== null && this.repetition_level_encoding !== undefined) {
        output.writeFieldBegin('repetition_level_encoding', Thrift.Type.I32, 4);
        output.writeI32(this.repetition_level_encoding);
        output.writeFieldEnd();
    }
    if (this.statistics !== null && this.statistics !== undefined) {
        output.writeFieldBegin('statistics', Thrift.Type.STRUCT, 5);
        this.statistics[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var IndexPageHeader = module.exports.IndexPageHeader = function (args) {
};
IndexPageHeader.prototype = {};
IndexPageHeader.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
IndexPageHeader.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('IndexPageHeader');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var DictionaryPageHeader = module.exports.DictionaryPageHeader = function (args) {
    this.num_values = null;
    this.encoding = null;
    this.is_sorted = null;
    if (args) {
        if (args.num_values !== undefined && args.num_values !== null) {
            this.num_values = args.num_values;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_values is unset!');
        }
        if (args.encoding !== undefined && args.encoding !== null) {
            this.encoding = args.encoding;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encoding is unset!');
        }
        if (args.is_sorted !== undefined && args.is_sorted !== null) {
            this.is_sorted = args.is_sorted;
        }
    }
};
DictionaryPageHeader.prototype = {};
DictionaryPageHeader.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.num_values = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.encoding = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.BOOL) {
                    this.is_sorted = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
DictionaryPageHeader.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('DictionaryPageHeader');
    if (this.num_values !== null && this.num_values !== undefined) {
        output.writeFieldBegin('num_values', Thrift.Type.I32, 1);
        output.writeI32(this.num_values);
        output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
        output.writeFieldBegin('encoding', Thrift.Type.I32, 2);
        output.writeI32(this.encoding);
        output.writeFieldEnd();
    }
    if (this.is_sorted !== null && this.is_sorted !== undefined) {
        output.writeFieldBegin('is_sorted', Thrift.Type.BOOL, 3);
        output.writeBool(this.is_sorted);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var DataPageHeaderV2 = module.exports.DataPageHeaderV2 = function (args) {
    this.num_values = null;
    this.num_nulls = null;
    this.num_rows = null;
    this.encoding = null;
    this.definition_levels_byte_length = null;
    this.repetition_levels_byte_length = null;
    this.is_compressed = true;
    this.statistics = null;
    if (args) {
        if (args.num_values !== undefined && args.num_values !== null) {
            this.num_values = args.num_values;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_values is unset!');
        }
        if (args.num_nulls !== undefined && args.num_nulls !== null) {
            this.num_nulls = args.num_nulls;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_nulls is unset!');
        }
        if (args.num_rows !== undefined && args.num_rows !== null) {
            this.num_rows = args.num_rows;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_rows is unset!');
        }
        if (args.encoding !== undefined && args.encoding !== null) {
            this.encoding = args.encoding;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encoding is unset!');
        }
        if (args.definition_levels_byte_length !== undefined && args.definition_levels_byte_length !== null) {
            this.definition_levels_byte_length = args.definition_levels_byte_length;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field definition_levels_byte_length is unset!');
        }
        if (args.repetition_levels_byte_length !== undefined && args.repetition_levels_byte_length !== null) {
            this.repetition_levels_byte_length = args.repetition_levels_byte_length;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field repetition_levels_byte_length is unset!');
        }
        if (args.is_compressed !== undefined && args.is_compressed !== null) {
            this.is_compressed = args.is_compressed;
        }
        if (args.statistics !== undefined && args.statistics !== null) {
            this.statistics = new ttypes.Statistics(args.statistics);
        }
    }
};
DataPageHeaderV2.prototype = {};
DataPageHeaderV2.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.num_values = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.num_nulls = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.num_rows = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.encoding = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I32) {
                    this.definition_levels_byte_length = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I32) {
                    this.repetition_levels_byte_length = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.BOOL) {
                    this.is_compressed = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.STRUCT) {
                    this.statistics = new ttypes.Statistics();
                    this.statistics[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
DataPageHeaderV2.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('DataPageHeaderV2');
    if (this.num_values !== null && this.num_values !== undefined) {
        output.writeFieldBegin('num_values', Thrift.Type.I32, 1);
        output.writeI32(this.num_values);
        output.writeFieldEnd();
    }
    if (this.num_nulls !== null && this.num_nulls !== undefined) {
        output.writeFieldBegin('num_nulls', Thrift.Type.I32, 2);
        output.writeI32(this.num_nulls);
        output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
        output.writeFieldBegin('num_rows', Thrift.Type.I32, 3);
        output.writeI32(this.num_rows);
        output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
        output.writeFieldBegin('encoding', Thrift.Type.I32, 4);
        output.writeI32(this.encoding);
        output.writeFieldEnd();
    }
    if (this.definition_levels_byte_length !== null && this.definition_levels_byte_length !== undefined) {
        output.writeFieldBegin('definition_levels_byte_length', Thrift.Type.I32, 5);
        output.writeI32(this.definition_levels_byte_length);
        output.writeFieldEnd();
    }
    if (this.repetition_levels_byte_length !== null && this.repetition_levels_byte_length !== undefined) {
        output.writeFieldBegin('repetition_levels_byte_length', Thrift.Type.I32, 6);
        output.writeI32(this.repetition_levels_byte_length);
        output.writeFieldEnd();
    }
    if (this.is_compressed !== null && this.is_compressed !== undefined) {
        output.writeFieldBegin('is_compressed', Thrift.Type.BOOL, 7);
        output.writeBool(this.is_compressed);
        output.writeFieldEnd();
    }
    if (this.statistics !== null && this.statistics !== undefined) {
        output.writeFieldBegin('statistics', Thrift.Type.STRUCT, 8);
        this.statistics[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var SplitBlockAlgorithm = module.exports.SplitBlockAlgorithm = function (args) {
};
SplitBlockAlgorithm.prototype = {};
SplitBlockAlgorithm.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
SplitBlockAlgorithm.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('SplitBlockAlgorithm');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var BloomFilterAlgorithm = module.exports.BloomFilterAlgorithm = function (args) {
    this.BLOCK = null;
    if (args) {
        if (args.BLOCK !== undefined && args.BLOCK !== null) {
            this.BLOCK = new ttypes.SplitBlockAlgorithm(args.BLOCK);
        }
    }
};
BloomFilterAlgorithm.prototype = {};
BloomFilterAlgorithm.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.BLOCK = new ttypes.SplitBlockAlgorithm();
                    this.BLOCK[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
BloomFilterAlgorithm.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('BloomFilterAlgorithm');
    if (this.BLOCK !== null && this.BLOCK !== undefined) {
        output.writeFieldBegin('BLOCK', Thrift.Type.STRUCT, 1);
        this.BLOCK[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var XxHash = module.exports.XxHash = function (args) {
};
XxHash.prototype = {};
XxHash.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
XxHash.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('XxHash');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var BloomFilterHash = module.exports.BloomFilterHash = function (args) {
    this.XXHASH = null;
    if (args) {
        if (args.XXHASH !== undefined && args.XXHASH !== null) {
            this.XXHASH = new ttypes.XxHash(args.XXHASH);
        }
    }
};
BloomFilterHash.prototype = {};
BloomFilterHash.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.XXHASH = new ttypes.XxHash();
                    this.XXHASH[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
BloomFilterHash.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('BloomFilterHash');
    if (this.XXHASH !== null && this.XXHASH !== undefined) {
        output.writeFieldBegin('XXHASH', Thrift.Type.STRUCT, 1);
        this.XXHASH[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var Uncompressed = module.exports.Uncompressed = function (args) {
};
Uncompressed.prototype = {};
Uncompressed.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
Uncompressed.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('Uncompressed');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var BloomFilterCompression = module.exports.BloomFilterCompression = function (args) {
    this.UNCOMPRESSED = null;
    if (args) {
        if (args.UNCOMPRESSED !== undefined && args.UNCOMPRESSED !== null) {
            this.UNCOMPRESSED = new ttypes.Uncompressed(args.UNCOMPRESSED);
        }
    }
};
BloomFilterCompression.prototype = {};
BloomFilterCompression.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.UNCOMPRESSED = new ttypes.Uncompressed();
                    this.UNCOMPRESSED[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
BloomFilterCompression.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('BloomFilterCompression');
    if (this.UNCOMPRESSED !== null && this.UNCOMPRESSED !== undefined) {
        output.writeFieldBegin('UNCOMPRESSED', Thrift.Type.STRUCT, 1);
        this.UNCOMPRESSED[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var BloomFilterHeader = module.exports.BloomFilterHeader = function (args) {
    this.numBytes = null;
    this.algorithm = null;
    this.hash = null;
    this.compression = null;
    if (args) {
        if (args.numBytes !== undefined && args.numBytes !== null) {
            this.numBytes = args.numBytes;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field numBytes is unset!');
        }
        if (args.algorithm !== undefined && args.algorithm !== null) {
            this.algorithm = new ttypes.BloomFilterAlgorithm(args.algorithm);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field algorithm is unset!');
        }
        if (args.hash !== undefined && args.hash !== null) {
            this.hash = new ttypes.BloomFilterHash(args.hash);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field hash is unset!');
        }
        if (args.compression !== undefined && args.compression !== null) {
            this.compression = new ttypes.BloomFilterCompression(args.compression);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field compression is unset!');
        }
    }
};
BloomFilterHeader.prototype = {};
BloomFilterHeader.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.numBytes = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.algorithm = new ttypes.BloomFilterAlgorithm();
                    this.algorithm[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.hash = new ttypes.BloomFilterHash();
                    this.hash[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRUCT) {
                    this.compression = new ttypes.BloomFilterCompression();
                    this.compression[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
BloomFilterHeader.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('BloomFilterHeader');
    if (this.numBytes !== null && this.numBytes !== undefined) {
        output.writeFieldBegin('numBytes', Thrift.Type.I32, 1);
        output.writeI32(this.numBytes);
        output.writeFieldEnd();
    }
    if (this.algorithm !== null && this.algorithm !== undefined) {
        output.writeFieldBegin('algorithm', Thrift.Type.STRUCT, 2);
        this.algorithm[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.hash !== null && this.hash !== undefined) {
        output.writeFieldBegin('hash', Thrift.Type.STRUCT, 3);
        this.hash[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.compression !== null && this.compression !== undefined) {
        output.writeFieldBegin('compression', Thrift.Type.STRUCT, 4);
        this.compression[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var PageHeader = module.exports.PageHeader = function (args) {
    this.type = null;
    this.uncompressed_page_size = null;
    this.compressed_page_size = null;
    this.crc = null;
    this.data_page_header = null;
    this.index_page_header = null;
    this.dictionary_page_header = null;
    this.data_page_header_v2 = null;
    if (args) {
        if (args.type !== undefined && args.type !== null) {
            this.type = args.type;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field type is unset!');
        }
        if (args.uncompressed_page_size !== undefined && args.uncompressed_page_size !== null) {
            this.uncompressed_page_size = args.uncompressed_page_size;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field uncompressed_page_size is unset!');
        }
        if (args.compressed_page_size !== undefined && args.compressed_page_size !== null) {
            this.compressed_page_size = args.compressed_page_size;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field compressed_page_size is unset!');
        }
        if (args.crc !== undefined && args.crc !== null) {
            this.crc = args.crc;
        }
        if (args.data_page_header !== undefined && args.data_page_header !== null) {
            this.data_page_header = new ttypes.DataPageHeader(args.data_page_header);
        }
        if (args.index_page_header !== undefined && args.index_page_header !== null) {
            this.index_page_header = new ttypes.IndexPageHeader(args.index_page_header);
        }
        if (args.dictionary_page_header !== undefined && args.dictionary_page_header !== null) {
            this.dictionary_page_header = new ttypes.DictionaryPageHeader(args.dictionary_page_header);
        }
        if (args.data_page_header_v2 !== undefined && args.data_page_header_v2 !== null) {
            this.data_page_header_v2 = new ttypes.DataPageHeaderV2(args.data_page_header_v2);
        }
    }
};
PageHeader.prototype = {};
PageHeader.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.type = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.uncompressed_page_size = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.compressed_page_size = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.crc = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRUCT) {
                    this.data_page_header = new ttypes.DataPageHeader();
                    this.data_page_header[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.STRUCT) {
                    this.index_page_header = new ttypes.IndexPageHeader();
                    this.index_page_header[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.STRUCT) {
                    this.dictionary_page_header = new ttypes.DictionaryPageHeader();
                    this.dictionary_page_header[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.STRUCT) {
                    this.data_page_header_v2 = new ttypes.DataPageHeaderV2();
                    this.data_page_header_v2[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
PageHeader.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('PageHeader');
    if (this.type !== null && this.type !== undefined) {
        output.writeFieldBegin('type', Thrift.Type.I32, 1);
        output.writeI32(this.type);
        output.writeFieldEnd();
    }
    if (this.uncompressed_page_size !== null && this.uncompressed_page_size !== undefined) {
        output.writeFieldBegin('uncompressed_page_size', Thrift.Type.I32, 2);
        output.writeI32(this.uncompressed_page_size);
        output.writeFieldEnd();
    }
    if (this.compressed_page_size !== null && this.compressed_page_size !== undefined) {
        output.writeFieldBegin('compressed_page_size', Thrift.Type.I32, 3);
        output.writeI32(this.compressed_page_size);
        output.writeFieldEnd();
    }
    if (this.crc !== null && this.crc !== undefined) {
        output.writeFieldBegin('crc', Thrift.Type.I32, 4);
        output.writeI32(this.crc);
        output.writeFieldEnd();
    }
    if (this.data_page_header !== null && this.data_page_header !== undefined) {
        output.writeFieldBegin('data_page_header', Thrift.Type.STRUCT, 5);
        this.data_page_header[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.index_page_header !== null && this.index_page_header !== undefined) {
        output.writeFieldBegin('index_page_header', Thrift.Type.STRUCT, 6);
        this.index_page_header[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.dictionary_page_header !== null && this.dictionary_page_header !== undefined) {
        output.writeFieldBegin('dictionary_page_header', Thrift.Type.STRUCT, 7);
        this.dictionary_page_header[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.data_page_header_v2 !== null && this.data_page_header_v2 !== undefined) {
        output.writeFieldBegin('data_page_header_v2', Thrift.Type.STRUCT, 8);
        this.data_page_header_v2[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var KeyValue = module.exports.KeyValue = function (args) {
    this.key = null;
    this.value = null;
    if (args) {
        if (args.key !== undefined && args.key !== null) {
            this.key = args.key;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field key is unset!');
        }
        if (args.value !== undefined && args.value !== null) {
            this.value = args.value;
        }
    }
};
KeyValue.prototype = {};
KeyValue.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.key = input.readString();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.value = input.readString();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
KeyValue.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('KeyValue');
    if (this.key !== null && this.key !== undefined) {
        output.writeFieldBegin('key', Thrift.Type.STRING, 1);
        output.writeString(this.key);
        output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
        output.writeFieldBegin('value', Thrift.Type.STRING, 2);
        output.writeString(this.value);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var SortingColumn = module.exports.SortingColumn = function (args) {
    this.column_idx = null;
    this.descending = null;
    this.nulls_first = null;
    if (args) {
        if (args.column_idx !== undefined && args.column_idx !== null) {
            this.column_idx = args.column_idx;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field column_idx is unset!');
        }
        if (args.descending !== undefined && args.descending !== null) {
            this.descending = args.descending;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field descending is unset!');
        }
        if (args.nulls_first !== undefined && args.nulls_first !== null) {
            this.nulls_first = args.nulls_first;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field nulls_first is unset!');
        }
    }
};
SortingColumn.prototype = {};
SortingColumn.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.column_idx = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.BOOL) {
                    this.descending = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.BOOL) {
                    this.nulls_first = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
SortingColumn.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('SortingColumn');
    if (this.column_idx !== null && this.column_idx !== undefined) {
        output.writeFieldBegin('column_idx', Thrift.Type.I32, 1);
        output.writeI32(this.column_idx);
        output.writeFieldEnd();
    }
    if (this.descending !== null && this.descending !== undefined) {
        output.writeFieldBegin('descending', Thrift.Type.BOOL, 2);
        output.writeBool(this.descending);
        output.writeFieldEnd();
    }
    if (this.nulls_first !== null && this.nulls_first !== undefined) {
        output.writeFieldBegin('nulls_first', Thrift.Type.BOOL, 3);
        output.writeBool(this.nulls_first);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var PageEncodingStats = module.exports.PageEncodingStats = function (args) {
    this.page_type = null;
    this.encoding = null;
    this.count = null;
    if (args) {
        if (args.page_type !== undefined && args.page_type !== null) {
            this.page_type = args.page_type;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field page_type is unset!');
        }
        if (args.encoding !== undefined && args.encoding !== null) {
            this.encoding = args.encoding;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encoding is unset!');
        }
        if (args.count !== undefined && args.count !== null) {
            this.count = args.count;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field count is unset!');
        }
    }
};
PageEncodingStats.prototype = {};
PageEncodingStats.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.page_type = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.encoding = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.count = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
PageEncodingStats.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('PageEncodingStats');
    if (this.page_type !== null && this.page_type !== undefined) {
        output.writeFieldBegin('page_type', Thrift.Type.I32, 1);
        output.writeI32(this.page_type);
        output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
        output.writeFieldBegin('encoding', Thrift.Type.I32, 2);
        output.writeI32(this.encoding);
        output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
        output.writeFieldBegin('count', Thrift.Type.I32, 3);
        output.writeI32(this.count);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var ColumnMetaData = module.exports.ColumnMetaData = function (args) {
    this.type = null;
    this.encodings = null;
    this.path_in_schema = null;
    this.codec = null;
    this.num_values = null;
    this.total_uncompressed_size = null;
    this.total_compressed_size = null;
    this.key_value_metadata = null;
    this.data_page_offset = null;
    this.index_page_offset = null;
    this.dictionary_page_offset = null;
    this.statistics = null;
    this.encoding_stats = null;
    this.bloom_filter_offset = null;
    this.bloom_filter_length = null;
    this.size_statistics = null;
    this.geospatial_statistics = null;
    if (args) {
        if (args.type !== undefined && args.type !== null) {
            this.type = args.type;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field type is unset!');
        }
        if (args.encodings !== undefined && args.encodings !== null) {
            this.encodings = Thrift.copyList(args.encodings, [null]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encodings is unset!');
        }
        if (args.path_in_schema !== undefined && args.path_in_schema !== null) {
            this.path_in_schema = Thrift.copyList(args.path_in_schema, [null]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field path_in_schema is unset!');
        }
        if (args.codec !== undefined && args.codec !== null) {
            this.codec = args.codec;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field codec is unset!');
        }
        if (args.num_values !== undefined && args.num_values !== null) {
            this.num_values = args.num_values;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_values is unset!');
        }
        if (args.total_uncompressed_size !== undefined && args.total_uncompressed_size !== null) {
            this.total_uncompressed_size = args.total_uncompressed_size;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field total_uncompressed_size is unset!');
        }
        if (args.total_compressed_size !== undefined && args.total_compressed_size !== null) {
            this.total_compressed_size = args.total_compressed_size;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field total_compressed_size is unset!');
        }
        if (args.key_value_metadata !== undefined && args.key_value_metadata !== null) {
            this.key_value_metadata = Thrift.copyList(args.key_value_metadata, [ttypes.KeyValue]);
        }
        if (args.data_page_offset !== undefined && args.data_page_offset !== null) {
            this.data_page_offset = args.data_page_offset;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field data_page_offset is unset!');
        }
        if (args.index_page_offset !== undefined && args.index_page_offset !== null) {
            this.index_page_offset = args.index_page_offset;
        }
        if (args.dictionary_page_offset !== undefined && args.dictionary_page_offset !== null) {
            this.dictionary_page_offset = args.dictionary_page_offset;
        }
        if (args.statistics !== undefined && args.statistics !== null) {
            this.statistics = new ttypes.Statistics(args.statistics);
        }
        if (args.encoding_stats !== undefined && args.encoding_stats !== null) {
            this.encoding_stats = Thrift.copyList(args.encoding_stats, [ttypes.PageEncodingStats]);
        }
        if (args.bloom_filter_offset !== undefined && args.bloom_filter_offset !== null) {
            this.bloom_filter_offset = args.bloom_filter_offset;
        }
        if (args.bloom_filter_length !== undefined && args.bloom_filter_length !== null) {
            this.bloom_filter_length = args.bloom_filter_length;
        }
        if (args.size_statistics !== undefined && args.size_statistics !== null) {
            this.size_statistics = new ttypes.SizeStatistics(args.size_statistics);
        }
        if (args.geospatial_statistics !== undefined && args.geospatial_statistics !== null) {
            this.geospatial_statistics = new ttypes.GeospatialStatistics(args.geospatial_statistics);
        }
    }
};
ColumnMetaData.prototype = {};
ColumnMetaData.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.type = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.LIST) {
                    this.encodings = [];
                    var _rtmp316 = input.readListBegin();
                    var _size15 = _rtmp316.size || 0;
                    for (var _i17 = 0; _i17 < _size15; ++_i17) {
                        var elem18 = null;
                        elem18 = input.readI32();
                        this.encodings.push(elem18);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.LIST) {
                    this.path_in_schema = [];
                    var _rtmp320 = input.readListBegin();
                    var _size19 = _rtmp320.size || 0;
                    for (var _i21 = 0; _i21 < _size19; ++_i21) {
                        var elem22 = null;
                        elem22 = input.readString();
                        this.path_in_schema.push(elem22);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.codec = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I64) {
                    this.num_values = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I64) {
                    this.total_uncompressed_size = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I64) {
                    this.total_compressed_size = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.LIST) {
                    this.key_value_metadata = [];
                    var _rtmp324 = input.readListBegin();
                    var _size23 = _rtmp324.size || 0;
                    for (var _i25 = 0; _i25 < _size23; ++_i25) {
                        var elem26 = null;
                        elem26 = new ttypes.KeyValue();
                        elem26[Symbol.for("read")](input);
                        this.key_value_metadata.push(elem26);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.I64) {
                    this.data_page_offset = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 10:
                if (ftype == Thrift.Type.I64) {
                    this.index_page_offset = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 11:
                if (ftype == Thrift.Type.I64) {
                    this.dictionary_page_offset = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 12:
                if (ftype == Thrift.Type.STRUCT) {
                    this.statistics = new ttypes.Statistics();
                    this.statistics[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 13:
                if (ftype == Thrift.Type.LIST) {
                    this.encoding_stats = [];
                    var _rtmp328 = input.readListBegin();
                    var _size27 = _rtmp328.size || 0;
                    for (var _i29 = 0; _i29 < _size27; ++_i29) {
                        var elem30 = null;
                        elem30 = new ttypes.PageEncodingStats();
                        elem30[Symbol.for("read")](input);
                        this.encoding_stats.push(elem30);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 14:
                if (ftype == Thrift.Type.I64) {
                    this.bloom_filter_offset = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 15:
                if (ftype == Thrift.Type.I32) {
                    this.bloom_filter_length = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 16:
                if (ftype == Thrift.Type.STRUCT) {
                    this.size_statistics = new ttypes.SizeStatistics();
                    this.size_statistics[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 17:
                if (ftype == Thrift.Type.STRUCT) {
                    this.geospatial_statistics = new ttypes.GeospatialStatistics();
                    this.geospatial_statistics[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
ColumnMetaData.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('ColumnMetaData');
    if (this.type !== null && this.type !== undefined) {
        output.writeFieldBegin('type', Thrift.Type.I32, 1);
        output.writeI32(this.type);
        output.writeFieldEnd();
    }
    if (this.encodings !== null && this.encodings !== undefined) {
        output.writeFieldBegin('encodings', Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.I32, this.encodings.length);
        for (var iter31 in this.encodings) {
            if (this.encodings.hasOwnProperty(iter31)) {
                iter31 = this.encodings[iter31];
                output.writeI32(iter31);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.path_in_schema !== null && this.path_in_schema !== undefined) {
        output.writeFieldBegin('path_in_schema', Thrift.Type.LIST, 3);
        output.writeListBegin(Thrift.Type.STRING, this.path_in_schema.length);
        for (var iter32 in this.path_in_schema) {
            if (this.path_in_schema.hasOwnProperty(iter32)) {
                iter32 = this.path_in_schema[iter32];
                output.writeString(iter32);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.codec !== null && this.codec !== undefined) {
        output.writeFieldBegin('codec', Thrift.Type.I32, 4);
        output.writeI32(this.codec);
        output.writeFieldEnd();
    }
    if (this.num_values !== null && this.num_values !== undefined) {
        output.writeFieldBegin('num_values', Thrift.Type.I64, 5);
        output.writeI64(this.num_values);
        output.writeFieldEnd();
    }
    if (this.total_uncompressed_size !== null && this.total_uncompressed_size !== undefined) {
        output.writeFieldBegin('total_uncompressed_size', Thrift.Type.I64, 6);
        output.writeI64(this.total_uncompressed_size);
        output.writeFieldEnd();
    }
    if (this.total_compressed_size !== null && this.total_compressed_size !== undefined) {
        output.writeFieldBegin('total_compressed_size', Thrift.Type.I64, 7);
        output.writeI64(this.total_compressed_size);
        output.writeFieldEnd();
    }
    if (this.key_value_metadata !== null && this.key_value_metadata !== undefined) {
        output.writeFieldBegin('key_value_metadata', Thrift.Type.LIST, 8);
        output.writeListBegin(Thrift.Type.STRUCT, this.key_value_metadata.length);
        for (var iter33 in this.key_value_metadata) {
            if (this.key_value_metadata.hasOwnProperty(iter33)) {
                iter33 = this.key_value_metadata[iter33];
                iter33[Symbol.for("write")](output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.data_page_offset !== null && this.data_page_offset !== undefined) {
        output.writeFieldBegin('data_page_offset', Thrift.Type.I64, 9);
        output.writeI64(this.data_page_offset);
        output.writeFieldEnd();
    }
    if (this.index_page_offset !== null && this.index_page_offset !== undefined) {
        output.writeFieldBegin('index_page_offset', Thrift.Type.I64, 10);
        output.writeI64(this.index_page_offset);
        output.writeFieldEnd();
    }
    if (this.dictionary_page_offset !== null && this.dictionary_page_offset !== undefined) {
        output.writeFieldBegin('dictionary_page_offset', Thrift.Type.I64, 11);
        output.writeI64(this.dictionary_page_offset);
        output.writeFieldEnd();
    }
    if (this.statistics !== null && this.statistics !== undefined) {
        output.writeFieldBegin('statistics', Thrift.Type.STRUCT, 12);
        this.statistics[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.encoding_stats !== null && this.encoding_stats !== undefined) {
        output.writeFieldBegin('encoding_stats', Thrift.Type.LIST, 13);
        output.writeListBegin(Thrift.Type.STRUCT, this.encoding_stats.length);
        for (var iter34 in this.encoding_stats) {
            if (this.encoding_stats.hasOwnProperty(iter34)) {
                iter34 = this.encoding_stats[iter34];
                iter34[Symbol.for("write")](output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.bloom_filter_offset !== null && this.bloom_filter_offset !== undefined) {
        output.writeFieldBegin('bloom_filter_offset', Thrift.Type.I64, 14);
        output.writeI64(this.bloom_filter_offset);
        output.writeFieldEnd();
    }
    if (this.bloom_filter_length !== null && this.bloom_filter_length !== undefined) {
        output.writeFieldBegin('bloom_filter_length', Thrift.Type.I32, 15);
        output.writeI32(this.bloom_filter_length);
        output.writeFieldEnd();
    }
    if (this.size_statistics !== null && this.size_statistics !== undefined) {
        output.writeFieldBegin('size_statistics', Thrift.Type.STRUCT, 16);
        this.size_statistics[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.geospatial_statistics !== null && this.geospatial_statistics !== undefined) {
        output.writeFieldBegin('geospatial_statistics', Thrift.Type.STRUCT, 17);
        this.geospatial_statistics[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var EncryptionWithFooterKey = module.exports.EncryptionWithFooterKey = function (args) {
};
EncryptionWithFooterKey.prototype = {};
EncryptionWithFooterKey.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
EncryptionWithFooterKey.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('EncryptionWithFooterKey');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var EncryptionWithColumnKey = module.exports.EncryptionWithColumnKey = function (args) {
    this.path_in_schema = null;
    this.key_metadata = null;
    if (args) {
        if (args.path_in_schema !== undefined && args.path_in_schema !== null) {
            this.path_in_schema = Thrift.copyList(args.path_in_schema, [null]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field path_in_schema is unset!');
        }
        if (args.key_metadata !== undefined && args.key_metadata !== null) {
            this.key_metadata = args.key_metadata;
        }
    }
};
EncryptionWithColumnKey.prototype = {};
EncryptionWithColumnKey.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.LIST) {
                    this.path_in_schema = [];
                    var _rtmp336 = input.readListBegin();
                    var _size35 = _rtmp336.size || 0;
                    for (var _i37 = 0; _i37 < _size35; ++_i37) {
                        var elem38 = null;
                        elem38 = input.readString();
                        this.path_in_schema.push(elem38);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.key_metadata = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
EncryptionWithColumnKey.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('EncryptionWithColumnKey');
    if (this.path_in_schema !== null && this.path_in_schema !== undefined) {
        output.writeFieldBegin('path_in_schema', Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRING, this.path_in_schema.length);
        for (var iter39 in this.path_in_schema) {
            if (this.path_in_schema.hasOwnProperty(iter39)) {
                iter39 = this.path_in_schema[iter39];
                output.writeString(iter39);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.key_metadata !== null && this.key_metadata !== undefined) {
        output.writeFieldBegin('key_metadata', Thrift.Type.STRING, 2);
        output.writeBinary(this.key_metadata);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var ColumnCryptoMetaData = module.exports.ColumnCryptoMetaData = function (args) {
    this.ENCRYPTION_WITH_FOOTER_KEY = null;
    this.ENCRYPTION_WITH_COLUMN_KEY = null;
    if (args) {
        if (args.ENCRYPTION_WITH_FOOTER_KEY !== undefined && args.ENCRYPTION_WITH_FOOTER_KEY !== null) {
            this.ENCRYPTION_WITH_FOOTER_KEY = new ttypes.EncryptionWithFooterKey(args.ENCRYPTION_WITH_FOOTER_KEY);
        }
        if (args.ENCRYPTION_WITH_COLUMN_KEY !== undefined && args.ENCRYPTION_WITH_COLUMN_KEY !== null) {
            this.ENCRYPTION_WITH_COLUMN_KEY = new ttypes.EncryptionWithColumnKey(args.ENCRYPTION_WITH_COLUMN_KEY);
        }
    }
};
ColumnCryptoMetaData.prototype = {};
ColumnCryptoMetaData.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.ENCRYPTION_WITH_FOOTER_KEY = new ttypes.EncryptionWithFooterKey();
                    this.ENCRYPTION_WITH_FOOTER_KEY[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.ENCRYPTION_WITH_COLUMN_KEY = new ttypes.EncryptionWithColumnKey();
                    this.ENCRYPTION_WITH_COLUMN_KEY[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
ColumnCryptoMetaData.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('ColumnCryptoMetaData');
    if (this.ENCRYPTION_WITH_FOOTER_KEY !== null && this.ENCRYPTION_WITH_FOOTER_KEY !== undefined) {
        output.writeFieldBegin('ENCRYPTION_WITH_FOOTER_KEY', Thrift.Type.STRUCT, 1);
        this.ENCRYPTION_WITH_FOOTER_KEY[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.ENCRYPTION_WITH_COLUMN_KEY !== null && this.ENCRYPTION_WITH_COLUMN_KEY !== undefined) {
        output.writeFieldBegin('ENCRYPTION_WITH_COLUMN_KEY', Thrift.Type.STRUCT, 2);
        this.ENCRYPTION_WITH_COLUMN_KEY[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var ColumnChunk = module.exports.ColumnChunk = function (args) {
    this.file_path = null;
    this.file_offset = new Int64(0);
    this.meta_data = null;
    this.offset_index_offset = null;
    this.offset_index_length = null;
    this.column_index_offset = null;
    this.column_index_length = null;
    this.crypto_metadata = null;
    this.encrypted_column_metadata = null;
    if (args) {
        if (args.file_path !== undefined && args.file_path !== null) {
            this.file_path = args.file_path;
        }
        if (args.file_offset !== undefined && args.file_offset !== null) {
            this.file_offset = args.file_offset;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field file_offset is unset!');
        }
        if (args.meta_data !== undefined && args.meta_data !== null) {
            this.meta_data = new ttypes.ColumnMetaData(args.meta_data);
        }
        if (args.offset_index_offset !== undefined && args.offset_index_offset !== null) {
            this.offset_index_offset = args.offset_index_offset;
        }
        if (args.offset_index_length !== undefined && args.offset_index_length !== null) {
            this.offset_index_length = args.offset_index_length;
        }
        if (args.column_index_offset !== undefined && args.column_index_offset !== null) {
            this.column_index_offset = args.column_index_offset;
        }
        if (args.column_index_length !== undefined && args.column_index_length !== null) {
            this.column_index_length = args.column_index_length;
        }
        if (args.crypto_metadata !== undefined && args.crypto_metadata !== null) {
            this.crypto_metadata = new ttypes.ColumnCryptoMetaData(args.crypto_metadata);
        }
        if (args.encrypted_column_metadata !== undefined && args.encrypted_column_metadata !== null) {
            this.encrypted_column_metadata = args.encrypted_column_metadata;
        }
    }
};
ColumnChunk.prototype = {};
ColumnChunk.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.file_path = input.readString();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I64) {
                    this.file_offset = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.meta_data = new ttypes.ColumnMetaData();
                    this.meta_data[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I64) {
                    this.offset_index_offset = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I32) {
                    this.offset_index_length = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I64) {
                    this.column_index_offset = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I32) {
                    this.column_index_length = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.STRUCT) {
                    this.crypto_metadata = new ttypes.ColumnCryptoMetaData();
                    this.crypto_metadata[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.STRING) {
                    this.encrypted_column_metadata = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
ColumnChunk.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('ColumnChunk');
    if (this.file_path !== null && this.file_path !== undefined) {
        output.writeFieldBegin('file_path', Thrift.Type.STRING, 1);
        output.writeString(this.file_path);
        output.writeFieldEnd();
    }
    if (this.file_offset !== null && this.file_offset !== undefined) {
        output.writeFieldBegin('file_offset', Thrift.Type.I64, 2);
        output.writeI64(this.file_offset);
        output.writeFieldEnd();
    }
    if (this.meta_data !== null && this.meta_data !== undefined) {
        output.writeFieldBegin('meta_data', Thrift.Type.STRUCT, 3);
        this.meta_data[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.offset_index_offset !== null && this.offset_index_offset !== undefined) {
        output.writeFieldBegin('offset_index_offset', Thrift.Type.I64, 4);
        output.writeI64(this.offset_index_offset);
        output.writeFieldEnd();
    }
    if (this.offset_index_length !== null && this.offset_index_length !== undefined) {
        output.writeFieldBegin('offset_index_length', Thrift.Type.I32, 5);
        output.writeI32(this.offset_index_length);
        output.writeFieldEnd();
    }
    if (this.column_index_offset !== null && this.column_index_offset !== undefined) {
        output.writeFieldBegin('column_index_offset', Thrift.Type.I64, 6);
        output.writeI64(this.column_index_offset);
        output.writeFieldEnd();
    }
    if (this.column_index_length !== null && this.column_index_length !== undefined) {
        output.writeFieldBegin('column_index_length', Thrift.Type.I32, 7);
        output.writeI32(this.column_index_length);
        output.writeFieldEnd();
    }
    if (this.crypto_metadata !== null && this.crypto_metadata !== undefined) {
        output.writeFieldBegin('crypto_metadata', Thrift.Type.STRUCT, 8);
        this.crypto_metadata[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.encrypted_column_metadata !== null && this.encrypted_column_metadata !== undefined) {
        output.writeFieldBegin('encrypted_column_metadata', Thrift.Type.STRING, 9);
        output.writeBinary(this.encrypted_column_metadata);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var RowGroup = module.exports.RowGroup = function (args) {
    this.columns = null;
    this.total_byte_size = null;
    this.num_rows = null;
    this.sorting_columns = null;
    this.file_offset = null;
    this.total_compressed_size = null;
    this.ordinal = null;
    if (args) {
        if (args.columns !== undefined && args.columns !== null) {
            this.columns = Thrift.copyList(args.columns, [ttypes.ColumnChunk]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field columns is unset!');
        }
        if (args.total_byte_size !== undefined && args.total_byte_size !== null) {
            this.total_byte_size = args.total_byte_size;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field total_byte_size is unset!');
        }
        if (args.num_rows !== undefined && args.num_rows !== null) {
            this.num_rows = args.num_rows;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_rows is unset!');
        }
        if (args.sorting_columns !== undefined && args.sorting_columns !== null) {
            this.sorting_columns = Thrift.copyList(args.sorting_columns, [ttypes.SortingColumn]);
        }
        if (args.file_offset !== undefined && args.file_offset !== null) {
            this.file_offset = args.file_offset;
        }
        if (args.total_compressed_size !== undefined && args.total_compressed_size !== null) {
            this.total_compressed_size = args.total_compressed_size;
        }
        if (args.ordinal !== undefined && args.ordinal !== null) {
            this.ordinal = args.ordinal;
        }
    }
};
RowGroup.prototype = {};
RowGroup.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.LIST) {
                    this.columns = [];
                    var _rtmp341 = input.readListBegin();
                    var _size40 = _rtmp341.size || 0;
                    for (var _i42 = 0; _i42 < _size40; ++_i42) {
                        var elem43 = null;
                        elem43 = new ttypes.ColumnChunk();
                        elem43[Symbol.for("read")](input);
                        this.columns.push(elem43);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I64) {
                    this.total_byte_size = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I64) {
                    this.num_rows = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.LIST) {
                    this.sorting_columns = [];
                    var _rtmp345 = input.readListBegin();
                    var _size44 = _rtmp345.size || 0;
                    for (var _i46 = 0; _i46 < _size44; ++_i46) {
                        var elem47 = null;
                        elem47 = new ttypes.SortingColumn();
                        elem47[Symbol.for("read")](input);
                        this.sorting_columns.push(elem47);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I64) {
                    this.file_offset = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I64) {
                    this.total_compressed_size = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I16) {
                    this.ordinal = input.readI16();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
RowGroup.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('RowGroup');
    if (this.columns !== null && this.columns !== undefined) {
        output.writeFieldBegin('columns', Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
        for (var iter48 in this.columns) {
            if (this.columns.hasOwnProperty(iter48)) {
                iter48 = this.columns[iter48];
                iter48[Symbol.for("write")](output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.total_byte_size !== null && this.total_byte_size !== undefined) {
        output.writeFieldBegin('total_byte_size', Thrift.Type.I64, 2);
        output.writeI64(this.total_byte_size);
        output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
        output.writeFieldBegin('num_rows', Thrift.Type.I64, 3);
        output.writeI64(this.num_rows);
        output.writeFieldEnd();
    }
    if (this.sorting_columns !== null && this.sorting_columns !== undefined) {
        output.writeFieldBegin('sorting_columns', Thrift.Type.LIST, 4);
        output.writeListBegin(Thrift.Type.STRUCT, this.sorting_columns.length);
        for (var iter49 in this.sorting_columns) {
            if (this.sorting_columns.hasOwnProperty(iter49)) {
                iter49 = this.sorting_columns[iter49];
                iter49[Symbol.for("write")](output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.file_offset !== null && this.file_offset !== undefined) {
        output.writeFieldBegin('file_offset', Thrift.Type.I64, 5);
        output.writeI64(this.file_offset);
        output.writeFieldEnd();
    }
    if (this.total_compressed_size !== null && this.total_compressed_size !== undefined) {
        output.writeFieldBegin('total_compressed_size', Thrift.Type.I64, 6);
        output.writeI64(this.total_compressed_size);
        output.writeFieldEnd();
    }
    if (this.ordinal !== null && this.ordinal !== undefined) {
        output.writeFieldBegin('ordinal', Thrift.Type.I16, 7);
        output.writeI16(this.ordinal);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var TypeDefinedOrder = module.exports.TypeDefinedOrder = function (args) {
};
TypeDefinedOrder.prototype = {};
TypeDefinedOrder.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        input.skip(ftype);
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
TypeDefinedOrder.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('TypeDefinedOrder');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var ColumnOrder = module.exports.ColumnOrder = function (args) {
    this.TYPE_ORDER = null;
    if (args) {
        if (args.TYPE_ORDER !== undefined && args.TYPE_ORDER !== null) {
            this.TYPE_ORDER = new ttypes.TypeDefinedOrder(args.TYPE_ORDER);
        }
    }
};
ColumnOrder.prototype = {};
ColumnOrder.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.TYPE_ORDER = new ttypes.TypeDefinedOrder();
                    this.TYPE_ORDER[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
ColumnOrder.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('ColumnOrder');
    if (this.TYPE_ORDER !== null && this.TYPE_ORDER !== undefined) {
        output.writeFieldBegin('TYPE_ORDER', Thrift.Type.STRUCT, 1);
        this.TYPE_ORDER[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var PageLocation = module.exports.PageLocation = function (args) {
    this.offset = null;
    this.compressed_page_size = null;
    this.first_row_index = null;
    if (args) {
        if (args.offset !== undefined && args.offset !== null) {
            this.offset = args.offset;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field offset is unset!');
        }
        if (args.compressed_page_size !== undefined && args.compressed_page_size !== null) {
            this.compressed_page_size = args.compressed_page_size;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field compressed_page_size is unset!');
        }
        if (args.first_row_index !== undefined && args.first_row_index !== null) {
            this.first_row_index = args.first_row_index;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field first_row_index is unset!');
        }
    }
};
PageLocation.prototype = {};
PageLocation.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I64) {
                    this.offset = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.compressed_page_size = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I64) {
                    this.first_row_index = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
PageLocation.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('PageLocation');
    if (this.offset !== null && this.offset !== undefined) {
        output.writeFieldBegin('offset', Thrift.Type.I64, 1);
        output.writeI64(this.offset);
        output.writeFieldEnd();
    }
    if (this.compressed_page_size !== null && this.compressed_page_size !== undefined) {
        output.writeFieldBegin('compressed_page_size', Thrift.Type.I32, 2);
        output.writeI32(this.compressed_page_size);
        output.writeFieldEnd();
    }
    if (this.first_row_index !== null && this.first_row_index !== undefined) {
        output.writeFieldBegin('first_row_index', Thrift.Type.I64, 3);
        output.writeI64(this.first_row_index);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var OffsetIndex = module.exports.OffsetIndex = function (args) {
    this.page_locations = null;
    this.unencoded_byte_array_data_bytes = null;
    if (args) {
        if (args.page_locations !== undefined && args.page_locations !== null) {
            this.page_locations = Thrift.copyList(args.page_locations, [ttypes.PageLocation]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field page_locations is unset!');
        }
        if (args.unencoded_byte_array_data_bytes !== undefined && args.unencoded_byte_array_data_bytes !== null) {
            this.unencoded_byte_array_data_bytes = Thrift.copyList(args.unencoded_byte_array_data_bytes, [null]);
        }
    }
};
OffsetIndex.prototype = {};
OffsetIndex.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.LIST) {
                    this.page_locations = [];
                    var _rtmp351 = input.readListBegin();
                    var _size50 = _rtmp351.size || 0;
                    for (var _i52 = 0; _i52 < _size50; ++_i52) {
                        var elem53 = null;
                        elem53 = new ttypes.PageLocation();
                        elem53[Symbol.for("read")](input);
                        this.page_locations.push(elem53);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.LIST) {
                    this.unencoded_byte_array_data_bytes = [];
                    var _rtmp355 = input.readListBegin();
                    var _size54 = _rtmp355.size || 0;
                    for (var _i56 = 0; _i56 < _size54; ++_i56) {
                        var elem57 = null;
                        elem57 = input.readI64();
                        this.unencoded_byte_array_data_bytes.push(elem57);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
OffsetIndex.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('OffsetIndex');
    if (this.page_locations !== null && this.page_locations !== undefined) {
        output.writeFieldBegin('page_locations', Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRUCT, this.page_locations.length);
        for (var iter58 in this.page_locations) {
            if (this.page_locations.hasOwnProperty(iter58)) {
                iter58 = this.page_locations[iter58];
                iter58[Symbol.for("write")](output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.unencoded_byte_array_data_bytes !== null && this.unencoded_byte_array_data_bytes !== undefined) {
        output.writeFieldBegin('unencoded_byte_array_data_bytes', Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.I64, this.unencoded_byte_array_data_bytes.length);
        for (var iter59 in this.unencoded_byte_array_data_bytes) {
            if (this.unencoded_byte_array_data_bytes.hasOwnProperty(iter59)) {
                iter59 = this.unencoded_byte_array_data_bytes[iter59];
                output.writeI64(iter59);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var ColumnIndex = module.exports.ColumnIndex = function (args) {
    this.null_pages = null;
    this.min_values = null;
    this.max_values = null;
    this.boundary_order = null;
    this.null_counts = null;
    this.repetition_level_histograms = null;
    this.definition_level_histograms = null;
    if (args) {
        if (args.null_pages !== undefined && args.null_pages !== null) {
            this.null_pages = Thrift.copyList(args.null_pages, [null]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field null_pages is unset!');
        }
        if (args.min_values !== undefined && args.min_values !== null) {
            this.min_values = Thrift.copyList(args.min_values, [null]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field min_values is unset!');
        }
        if (args.max_values !== undefined && args.max_values !== null) {
            this.max_values = Thrift.copyList(args.max_values, [null]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field max_values is unset!');
        }
        if (args.boundary_order !== undefined && args.boundary_order !== null) {
            this.boundary_order = args.boundary_order;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field boundary_order is unset!');
        }
        if (args.null_counts !== undefined && args.null_counts !== null) {
            this.null_counts = Thrift.copyList(args.null_counts, [null]);
        }
        if (args.repetition_level_histograms !== undefined && args.repetition_level_histograms !== null) {
            this.repetition_level_histograms = Thrift.copyList(args.repetition_level_histograms, [null]);
        }
        if (args.definition_level_histograms !== undefined && args.definition_level_histograms !== null) {
            this.definition_level_histograms = Thrift.copyList(args.definition_level_histograms, [null]);
        }
    }
};
ColumnIndex.prototype = {};
ColumnIndex.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.LIST) {
                    this.null_pages = [];
                    var _rtmp361 = input.readListBegin();
                    var _size60 = _rtmp361.size || 0;
                    for (var _i62 = 0; _i62 < _size60; ++_i62) {
                        var elem63 = null;
                        elem63 = input.readBool();
                        this.null_pages.push(elem63);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.LIST) {
                    this.min_values = [];
                    var _rtmp365 = input.readListBegin();
                    var _size64 = _rtmp365.size || 0;
                    for (var _i66 = 0; _i66 < _size64; ++_i66) {
                        var elem67 = null;
                        elem67 = input.readBinary();
                        this.min_values.push(elem67);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.LIST) {
                    this.max_values = [];
                    var _rtmp369 = input.readListBegin();
                    var _size68 = _rtmp369.size || 0;
                    for (var _i70 = 0; _i70 < _size68; ++_i70) {
                        var elem71 = null;
                        elem71 = input.readBinary();
                        this.max_values.push(elem71);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.boundary_order = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.LIST) {
                    this.null_counts = [];
                    var _rtmp373 = input.readListBegin();
                    var _size72 = _rtmp373.size || 0;
                    for (var _i74 = 0; _i74 < _size72; ++_i74) {
                        var elem75 = null;
                        elem75 = input.readI64();
                        this.null_counts.push(elem75);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.LIST) {
                    this.repetition_level_histograms = [];
                    var _rtmp377 = input.readListBegin();
                    var _size76 = _rtmp377.size || 0;
                    for (var _i78 = 0; _i78 < _size76; ++_i78) {
                        var elem79 = null;
                        elem79 = input.readI64();
                        this.repetition_level_histograms.push(elem79);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.LIST) {
                    this.definition_level_histograms = [];
                    var _rtmp381 = input.readListBegin();
                    var _size80 = _rtmp381.size || 0;
                    for (var _i82 = 0; _i82 < _size80; ++_i82) {
                        var elem83 = null;
                        elem83 = input.readI64();
                        this.definition_level_histograms.push(elem83);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
ColumnIndex.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('ColumnIndex');
    if (this.null_pages !== null && this.null_pages !== undefined) {
        output.writeFieldBegin('null_pages', Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.BOOL, this.null_pages.length);
        for (var iter84 in this.null_pages) {
            if (this.null_pages.hasOwnProperty(iter84)) {
                iter84 = this.null_pages[iter84];
                output.writeBool(iter84);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.min_values !== null && this.min_values !== undefined) {
        output.writeFieldBegin('min_values', Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.STRING, this.min_values.length);
        for (var iter85 in this.min_values) {
            if (this.min_values.hasOwnProperty(iter85)) {
                iter85 = this.min_values[iter85];
                output.writeBinary(iter85);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.max_values !== null && this.max_values !== undefined) {
        output.writeFieldBegin('max_values', Thrift.Type.LIST, 3);
        output.writeListBegin(Thrift.Type.STRING, this.max_values.length);
        for (var iter86 in this.max_values) {
            if (this.max_values.hasOwnProperty(iter86)) {
                iter86 = this.max_values[iter86];
                output.writeBinary(iter86);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.boundary_order !== null && this.boundary_order !== undefined) {
        output.writeFieldBegin('boundary_order', Thrift.Type.I32, 4);
        output.writeI32(this.boundary_order);
        output.writeFieldEnd();
    }
    if (this.null_counts !== null && this.null_counts !== undefined) {
        output.writeFieldBegin('null_counts', Thrift.Type.LIST, 5);
        output.writeListBegin(Thrift.Type.I64, this.null_counts.length);
        for (var iter87 in this.null_counts) {
            if (this.null_counts.hasOwnProperty(iter87)) {
                iter87 = this.null_counts[iter87];
                output.writeI64(iter87);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.repetition_level_histograms !== null && this.repetition_level_histograms !== undefined) {
        output.writeFieldBegin('repetition_level_histograms', Thrift.Type.LIST, 6);
        output.writeListBegin(Thrift.Type.I64, this.repetition_level_histograms.length);
        for (var iter88 in this.repetition_level_histograms) {
            if (this.repetition_level_histograms.hasOwnProperty(iter88)) {
                iter88 = this.repetition_level_histograms[iter88];
                output.writeI64(iter88);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.definition_level_histograms !== null && this.definition_level_histograms !== undefined) {
        output.writeFieldBegin('definition_level_histograms', Thrift.Type.LIST, 7);
        output.writeListBegin(Thrift.Type.I64, this.definition_level_histograms.length);
        for (var iter89 in this.definition_level_histograms) {
            if (this.definition_level_histograms.hasOwnProperty(iter89)) {
                iter89 = this.definition_level_histograms[iter89];
                output.writeI64(iter89);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var AesGcmV1 = module.exports.AesGcmV1 = function (args) {
    this.aad_prefix = null;
    this.aad_file_unique = null;
    this.supply_aad_prefix = null;
    if (args) {
        if (args.aad_prefix !== undefined && args.aad_prefix !== null) {
            this.aad_prefix = args.aad_prefix;
        }
        if (args.aad_file_unique !== undefined && args.aad_file_unique !== null) {
            this.aad_file_unique = args.aad_file_unique;
        }
        if (args.supply_aad_prefix !== undefined && args.supply_aad_prefix !== null) {
            this.supply_aad_prefix = args.supply_aad_prefix;
        }
    }
};
AesGcmV1.prototype = {};
AesGcmV1.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.aad_prefix = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.aad_file_unique = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.BOOL) {
                    this.supply_aad_prefix = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
AesGcmV1.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('AesGcmV1');
    if (this.aad_prefix !== null && this.aad_prefix !== undefined) {
        output.writeFieldBegin('aad_prefix', Thrift.Type.STRING, 1);
        output.writeBinary(this.aad_prefix);
        output.writeFieldEnd();
    }
    if (this.aad_file_unique !== null && this.aad_file_unique !== undefined) {
        output.writeFieldBegin('aad_file_unique', Thrift.Type.STRING, 2);
        output.writeBinary(this.aad_file_unique);
        output.writeFieldEnd();
    }
    if (this.supply_aad_prefix !== null && this.supply_aad_prefix !== undefined) {
        output.writeFieldBegin('supply_aad_prefix', Thrift.Type.BOOL, 3);
        output.writeBool(this.supply_aad_prefix);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var AesGcmCtrV1 = module.exports.AesGcmCtrV1 = function (args) {
    this.aad_prefix = null;
    this.aad_file_unique = null;
    this.supply_aad_prefix = null;
    if (args) {
        if (args.aad_prefix !== undefined && args.aad_prefix !== null) {
            this.aad_prefix = args.aad_prefix;
        }
        if (args.aad_file_unique !== undefined && args.aad_file_unique !== null) {
            this.aad_file_unique = args.aad_file_unique;
        }
        if (args.supply_aad_prefix !== undefined && args.supply_aad_prefix !== null) {
            this.supply_aad_prefix = args.supply_aad_prefix;
        }
    }
};
AesGcmCtrV1.prototype = {};
AesGcmCtrV1.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.aad_prefix = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.aad_file_unique = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.BOOL) {
                    this.supply_aad_prefix = input.readBool();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
AesGcmCtrV1.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('AesGcmCtrV1');
    if (this.aad_prefix !== null && this.aad_prefix !== undefined) {
        output.writeFieldBegin('aad_prefix', Thrift.Type.STRING, 1);
        output.writeBinary(this.aad_prefix);
        output.writeFieldEnd();
    }
    if (this.aad_file_unique !== null && this.aad_file_unique !== undefined) {
        output.writeFieldBegin('aad_file_unique', Thrift.Type.STRING, 2);
        output.writeBinary(this.aad_file_unique);
        output.writeFieldEnd();
    }
    if (this.supply_aad_prefix !== null && this.supply_aad_prefix !== undefined) {
        output.writeFieldBegin('supply_aad_prefix', Thrift.Type.BOOL, 3);
        output.writeBool(this.supply_aad_prefix);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var EncryptionAlgorithm = module.exports.EncryptionAlgorithm = function (args) {
    this.AES_GCM_V1 = null;
    this.AES_GCM_CTR_V1 = null;
    if (args) {
        if (args.AES_GCM_V1 !== undefined && args.AES_GCM_V1 !== null) {
            this.AES_GCM_V1 = new ttypes.AesGcmV1(args.AES_GCM_V1);
        }
        if (args.AES_GCM_CTR_V1 !== undefined && args.AES_GCM_CTR_V1 !== null) {
            this.AES_GCM_CTR_V1 = new ttypes.AesGcmCtrV1(args.AES_GCM_CTR_V1);
        }
    }
};
EncryptionAlgorithm.prototype = {};
EncryptionAlgorithm.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.AES_GCM_V1 = new ttypes.AesGcmV1();
                    this.AES_GCM_V1[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.AES_GCM_CTR_V1 = new ttypes.AesGcmCtrV1();
                    this.AES_GCM_CTR_V1[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
EncryptionAlgorithm.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('EncryptionAlgorithm');
    if (this.AES_GCM_V1 !== null && this.AES_GCM_V1 !== undefined) {
        output.writeFieldBegin('AES_GCM_V1', Thrift.Type.STRUCT, 1);
        this.AES_GCM_V1[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.AES_GCM_CTR_V1 !== null && this.AES_GCM_CTR_V1 !== undefined) {
        output.writeFieldBegin('AES_GCM_CTR_V1', Thrift.Type.STRUCT, 2);
        this.AES_GCM_CTR_V1[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var FileMetaData = module.exports.FileMetaData = function (args) {
    this.version = null;
    this.schema = null;
    this.num_rows = null;
    this.row_groups = null;
    this.key_value_metadata = null;
    this.created_by = null;
    this.column_orders = null;
    this.encryption_algorithm = null;
    this.footer_signing_key_metadata = null;
    if (args) {
        if (args.version !== undefined && args.version !== null) {
            this.version = args.version;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field version is unset!');
        }
        if (args.schema !== undefined && args.schema !== null) {
            this.schema = Thrift.copyList(args.schema, [ttypes.SchemaElement]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field schema is unset!');
        }
        if (args.num_rows !== undefined && args.num_rows !== null) {
            this.num_rows = args.num_rows;
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field num_rows is unset!');
        }
        if (args.row_groups !== undefined && args.row_groups !== null) {
            this.row_groups = Thrift.copyList(args.row_groups, [ttypes.RowGroup]);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field row_groups is unset!');
        }
        if (args.key_value_metadata !== undefined && args.key_value_metadata !== null) {
            this.key_value_metadata = Thrift.copyList(args.key_value_metadata, [ttypes.KeyValue]);
        }
        if (args.created_by !== undefined && args.created_by !== null) {
            this.created_by = args.created_by;
        }
        if (args.column_orders !== undefined && args.column_orders !== null) {
            this.column_orders = Thrift.copyList(args.column_orders, [ttypes.ColumnOrder]);
        }
        if (args.encryption_algorithm !== undefined && args.encryption_algorithm !== null) {
            this.encryption_algorithm = new ttypes.EncryptionAlgorithm(args.encryption_algorithm);
        }
        if (args.footer_signing_key_metadata !== undefined && args.footer_signing_key_metadata !== null) {
            this.footer_signing_key_metadata = args.footer_signing_key_metadata;
        }
    }
};
FileMetaData.prototype = {};
FileMetaData.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.version = input.readI32();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.LIST) {
                    this.schema = [];
                    var _rtmp391 = input.readListBegin();
                    var _size90 = _rtmp391.size || 0;
                    for (var _i92 = 0; _i92 < _size90; ++_i92) {
                        var elem93 = null;
                        elem93 = new ttypes.SchemaElement();
                        elem93[Symbol.for("read")](input);
                        this.schema.push(elem93);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I64) {
                    this.num_rows = input.readI64();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.LIST) {
                    this.row_groups = [];
                    var _rtmp395 = input.readListBegin();
                    var _size94 = _rtmp395.size || 0;
                    for (var _i96 = 0; _i96 < _size94; ++_i96) {
                        var elem97 = null;
                        elem97 = new ttypes.RowGroup();
                        elem97[Symbol.for("read")](input);
                        this.row_groups.push(elem97);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.LIST) {
                    this.key_value_metadata = [];
                    var _rtmp399 = input.readListBegin();
                    var _size98 = _rtmp399.size || 0;
                    for (var _i100 = 0; _i100 < _size98; ++_i100) {
                        var elem101 = null;
                        elem101 = new ttypes.KeyValue();
                        elem101[Symbol.for("read")](input);
                        this.key_value_metadata.push(elem101);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.STRING) {
                    this.created_by = input.readString();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.LIST) {
                    this.column_orders = [];
                    var _rtmp3103 = input.readListBegin();
                    var _size102 = _rtmp3103.size || 0;
                    for (var _i104 = 0; _i104 < _size102; ++_i104) {
                        var elem105 = null;
                        elem105 = new ttypes.ColumnOrder();
                        elem105[Symbol.for("read")](input);
                        this.column_orders.push(elem105);
                    }
                    input.readListEnd();
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.STRUCT) {
                    this.encryption_algorithm = new ttypes.EncryptionAlgorithm();
                    this.encryption_algorithm[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.STRING) {
                    this.footer_signing_key_metadata = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
FileMetaData.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('FileMetaData');
    if (this.version !== null && this.version !== undefined) {
        output.writeFieldBegin('version', Thrift.Type.I32, 1);
        output.writeI32(this.version);
        output.writeFieldEnd();
    }
    if (this.schema !== null && this.schema !== undefined) {
        output.writeFieldBegin('schema', Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.STRUCT, this.schema.length);
        for (var iter106 in this.schema) {
            if (this.schema.hasOwnProperty(iter106)) {
                iter106 = this.schema[iter106];
                iter106[Symbol.for("write")](output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
        output.writeFieldBegin('num_rows', Thrift.Type.I64, 3);
        output.writeI64(this.num_rows);
        output.writeFieldEnd();
    }
    if (this.row_groups !== null && this.row_groups !== undefined) {
        output.writeFieldBegin('row_groups', Thrift.Type.LIST, 4);
        output.writeListBegin(Thrift.Type.STRUCT, this.row_groups.length);
        for (var iter107 in this.row_groups) {
            if (this.row_groups.hasOwnProperty(iter107)) {
                iter107 = this.row_groups[iter107];
                iter107[Symbol.for("write")](output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.key_value_metadata !== null && this.key_value_metadata !== undefined) {
        output.writeFieldBegin('key_value_metadata', Thrift.Type.LIST, 5);
        output.writeListBegin(Thrift.Type.STRUCT, this.key_value_metadata.length);
        for (var iter108 in this.key_value_metadata) {
            if (this.key_value_metadata.hasOwnProperty(iter108)) {
                iter108 = this.key_value_metadata[iter108];
                iter108[Symbol.for("write")](output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.created_by !== null && this.created_by !== undefined) {
        output.writeFieldBegin('created_by', Thrift.Type.STRING, 6);
        output.writeString(this.created_by);
        output.writeFieldEnd();
    }
    if (this.column_orders !== null && this.column_orders !== undefined) {
        output.writeFieldBegin('column_orders', Thrift.Type.LIST, 7);
        output.writeListBegin(Thrift.Type.STRUCT, this.column_orders.length);
        for (var iter109 in this.column_orders) {
            if (this.column_orders.hasOwnProperty(iter109)) {
                iter109 = this.column_orders[iter109];
                iter109[Symbol.for("write")](output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.encryption_algorithm !== null && this.encryption_algorithm !== undefined) {
        output.writeFieldBegin('encryption_algorithm', Thrift.Type.STRUCT, 8);
        this.encryption_algorithm[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.footer_signing_key_metadata !== null && this.footer_signing_key_metadata !== undefined) {
        output.writeFieldBegin('footer_signing_key_metadata', Thrift.Type.STRING, 9);
        output.writeBinary(this.footer_signing_key_metadata);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
var FileCryptoMetaData = module.exports.FileCryptoMetaData = function (args) {
    this.encryption_algorithm = null;
    this.key_metadata = null;
    if (args) {
        if (args.encryption_algorithm !== undefined && args.encryption_algorithm !== null) {
            this.encryption_algorithm = new ttypes.EncryptionAlgorithm(args.encryption_algorithm);
        }
        else {
            throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field encryption_algorithm is unset!');
        }
        if (args.key_metadata !== undefined && args.key_metadata !== null) {
            this.key_metadata = args.key_metadata;
        }
    }
};
FileCryptoMetaData.prototype = {};
FileCryptoMetaData.prototype[Symbol.for("read")] = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.encryption_algorithm = new ttypes.EncryptionAlgorithm();
                    this.encryption_algorithm[Symbol.for("read")](input);
                }
                else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.key_metadata = input.readBinary();
                }
                else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};
FileCryptoMetaData.prototype[Symbol.for("write")] = function (output) {
    output.writeStructBegin('FileCryptoMetaData');
    if (this.encryption_algorithm !== null && this.encryption_algorithm !== undefined) {
        output.writeFieldBegin('encryption_algorithm', Thrift.Type.STRUCT, 1);
        this.encryption_algorithm[Symbol.for("write")](output);
        output.writeFieldEnd();
    }
    if (this.key_metadata !== null && this.key_metadata !== undefined) {
        output.writeFieldBegin('key_metadata', Thrift.Type.STRING, 2);
        output.writeBinary(this.key_metadata);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};
